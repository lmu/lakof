(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[0],{

/***/ "./.plone/++plone++static/components/backbone/backbone.js":
/*!****************************************************************!*\
  !*** ./.plone/++plone++static/components/backbone/backbone.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Backbone.js 1.1.2\n\n//     (c) 2010-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Backbone may be freely distributed under the MIT license.\n//     For all details and documentation:\n//     http://backbonejs.org\n\n(function(root, factory) {\n\n  // Set up Backbone appropriately for the environment. Start with AMD.\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! underscore */ \"./.plone/++plone++static/components/underscore/underscore.js\"), __webpack_require__(/*! jquery */ \"./.plone/++plone++static/components/jquery/dist/jquery.min.js\"), exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function(_, $, exports) {\n      // Export global even in AMD case in case this script is loaded with\n      // others that may still expect a global Backbone.\n      root.Backbone = factory(root, exports, _, $);\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n  // Next for Node.js or CommonJS. jQuery may not be needed as a module.\n  } else { var _; }\n\n}(this, function(root, Backbone, _, $) {\n\n  // Initial Setup\n  // -------------\n\n  // Save the previous value of the `Backbone` variable, so that it can be\n  // restored later on, if `noConflict` is used.\n  var previousBackbone = root.Backbone;\n\n  // Create local references to array methods we'll want to use later.\n  var array = [];\n  var push = array.push;\n  var slice = array.slice;\n  var splice = array.splice;\n\n  // Current version of the library. Keep in sync with `package.json`.\n  Backbone.VERSION = '1.1.2';\n\n  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns\n  // the `$` variable.\n  Backbone.$ = $;\n\n  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable\n  // to its previous owner. Returns a reference to this Backbone object.\n  Backbone.noConflict = function() {\n    root.Backbone = previousBackbone;\n    return this;\n  };\n\n  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option\n  // will fake `\"PATCH\"`, `\"PUT\"` and `\"DELETE\"` requests via the `_method` parameter and\n  // set a `X-Http-Method-Override` header.\n  Backbone.emulateHTTP = false;\n\n  // Turn on `emulateJSON` to support legacy servers that can't deal with direct\n  // `application/json` requests ... will encode the body as\n  // `application/x-www-form-urlencoded` instead and will send the model in a\n  // form param named `model`.\n  Backbone.emulateJSON = false;\n\n  // Backbone.Events\n  // ---------------\n\n  // A module that can be mixed in to *any object* in order to provide it with\n  // custom events. You may bind with `on` or remove with `off` callback\n  // functions to an event; `trigger`-ing an event fires all callbacks in\n  // succession.\n  //\n  //     var object = {};\n  //     _.extend(object, Backbone.Events);\n  //     object.on('expand', function(){ alert('expanded'); });\n  //     object.trigger('expand');\n  //\n  var Events = Backbone.Events = {\n\n    // Bind an event to a `callback` function. Passing `\"all\"` will bind\n    // the callback to all events fired.\n    on: function(name, callback, context) {\n      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;\n      this._events || (this._events = {});\n      var events = this._events[name] || (this._events[name] = []);\n      events.push({callback: callback, context: context, ctx: context || this});\n      return this;\n    },\n\n    // Bind an event to only be triggered a single time. After the first time\n    // the callback is invoked, it will be removed.\n    once: function(name, callback, context) {\n      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;\n      var self = this;\n      var once = _.once(function() {\n        self.off(name, once);\n        callback.apply(this, arguments);\n      });\n      once._callback = callback;\n      return this.on(name, once, context);\n    },\n\n    // Remove one or many callbacks. If `context` is null, removes all\n    // callbacks with that function. If `callback` is null, removes all\n    // callbacks for the event. If `name` is null, removes all bound\n    // callbacks for all events.\n    off: function(name, callback, context) {\n      var retain, ev, events, names, i, l, j, k;\n      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;\n      if (!name && !callback && !context) {\n        this._events = void 0;\n        return this;\n      }\n      names = name ? [name] : _.keys(this._events);\n      for (i = 0, l = names.length; i < l; i++) {\n        name = names[i];\n        if (events = this._events[name]) {\n          this._events[name] = retain = [];\n          if (callback || context) {\n            for (j = 0, k = events.length; j < k; j++) {\n              ev = events[j];\n              if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||\n                  (context && context !== ev.context)) {\n                retain.push(ev);\n              }\n            }\n          }\n          if (!retain.length) delete this._events[name];\n        }\n      }\n\n      return this;\n    },\n\n    // Trigger one or many events, firing all bound callbacks. Callbacks are\n    // passed the same arguments as `trigger` is, apart from the event name\n    // (unless you're listening on `\"all\"`, which will cause your callback to\n    // receive the true name of the event as the first argument).\n    trigger: function(name) {\n      if (!this._events) return this;\n      var args = slice.call(arguments, 1);\n      if (!eventsApi(this, 'trigger', name, args)) return this;\n      var events = this._events[name];\n      var allEvents = this._events.all;\n      if (events) triggerEvents(events, args);\n      if (allEvents) triggerEvents(allEvents, arguments);\n      return this;\n    },\n\n    // Tell this object to stop listening to either specific events ... or\n    // to every object it's currently listening to.\n    stopListening: function(obj, name, callback) {\n      var listeningTo = this._listeningTo;\n      if (!listeningTo) return this;\n      var remove = !name && !callback;\n      if (!callback && typeof name === 'object') callback = this;\n      if (obj) (listeningTo = {})[obj._listenId] = obj;\n      for (var id in listeningTo) {\n        obj = listeningTo[id];\n        obj.off(name, callback, this);\n        if (remove || _.isEmpty(obj._events)) delete this._listeningTo[id];\n      }\n      return this;\n    }\n\n  };\n\n  // Regular expression used to split event strings.\n  var eventSplitter = /\\s+/;\n\n  // Implement fancy features of the Events API such as multiple event\n  // names `\"change blur\"` and jQuery-style event maps `{change: action}`\n  // in terms of the existing API.\n  var eventsApi = function(obj, action, name, rest) {\n    if (!name) return true;\n\n    // Handle event maps.\n    if (typeof name === 'object') {\n      for (var key in name) {\n        obj[action].apply(obj, [key, name[key]].concat(rest));\n      }\n      return false;\n    }\n\n    // Handle space separated event names.\n    if (eventSplitter.test(name)) {\n      var names = name.split(eventSplitter);\n      for (var i = 0, l = names.length; i < l; i++) {\n        obj[action].apply(obj, [names[i]].concat(rest));\n      }\n      return false;\n    }\n\n    return true;\n  };\n\n  // A difficult-to-believe, but optimized internal dispatch function for\n  // triggering events. Tries to keep the usual cases speedy (most internal\n  // Backbone events have 3 arguments).\n  var triggerEvents = function(events, args) {\n    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];\n    switch (args.length) {\n      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;\n      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;\n      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;\n      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;\n      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args); return;\n    }\n  };\n\n  var listenMethods = {listenTo: 'on', listenToOnce: 'once'};\n\n  // Inversion-of-control versions of `on` and `once`. Tell *this* object to\n  // listen to an event in another object ... keeping track of what it's\n  // listening to.\n  _.each(listenMethods, function(implementation, method) {\n    Events[method] = function(obj, name, callback) {\n      var listeningTo = this._listeningTo || (this._listeningTo = {});\n      var id = obj._listenId || (obj._listenId = _.uniqueId('l'));\n      listeningTo[id] = obj;\n      if (!callback && typeof name === 'object') callback = this;\n      obj[implementation](name, callback, this);\n      return this;\n    };\n  });\n\n  // Aliases for backwards compatibility.\n  Events.bind   = Events.on;\n  Events.unbind = Events.off;\n\n  // Allow the `Backbone` object to serve as a global event bus, for folks who\n  // want global \"pubsub\" in a convenient place.\n  _.extend(Backbone, Events);\n\n  // Backbone.Model\n  // --------------\n\n  // Backbone **Models** are the basic data object in the framework --\n  // frequently representing a row in a table in a database on your server.\n  // A discrete chunk of data and a bunch of useful, related methods for\n  // performing computations and transformations on that data.\n\n  // Create a new model with the specified attributes. A client id (`cid`)\n  // is automatically generated and assigned for you.\n  var Model = Backbone.Model = function(attributes, options) {\n    var attrs = attributes || {};\n    options || (options = {});\n    this.cid = _.uniqueId('c');\n    this.attributes = {};\n    if (options.collection) this.collection = options.collection;\n    if (options.parse) attrs = this.parse(attrs, options) || {};\n    attrs = _.defaults({}, attrs, _.result(this, 'defaults'));\n    this.set(attrs, options);\n    this.changed = {};\n    this.initialize.apply(this, arguments);\n  };\n\n  // Attach all inheritable methods to the Model prototype.\n  _.extend(Model.prototype, Events, {\n\n    // A hash of attributes whose current and previous value differ.\n    changed: null,\n\n    // The value returned during the last failed validation.\n    validationError: null,\n\n    // The default name for the JSON `id` attribute is `\"id\"`. MongoDB and\n    // CouchDB users may want to set this to `\"_id\"`.\n    idAttribute: 'id',\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){},\n\n    // Return a copy of the model's `attributes` object.\n    toJSON: function(options) {\n      return _.clone(this.attributes);\n    },\n\n    // Proxy `Backbone.sync` by default -- but override this if you need\n    // custom syncing semantics for *this* particular model.\n    sync: function() {\n      return Backbone.sync.apply(this, arguments);\n    },\n\n    // Get the value of an attribute.\n    get: function(attr) {\n      return this.attributes[attr];\n    },\n\n    // Get the HTML-escaped value of an attribute.\n    escape: function(attr) {\n      return _.escape(this.get(attr));\n    },\n\n    // Returns `true` if the attribute contains a value that is not null\n    // or undefined.\n    has: function(attr) {\n      return this.get(attr) != null;\n    },\n\n    // Set a hash of model attributes on the object, firing `\"change\"`. This is\n    // the core primitive operation of a model, updating the data and notifying\n    // anyone who needs to know about the change in state. The heart of the beast.\n    set: function(key, val, options) {\n      var attr, attrs, unset, changes, silent, changing, prev, current;\n      if (key == null) return this;\n\n      // Handle both `\"key\", value` and `{key: value}` -style arguments.\n      if (typeof key === 'object') {\n        attrs = key;\n        options = val;\n      } else {\n        (attrs = {})[key] = val;\n      }\n\n      options || (options = {});\n\n      // Run validation.\n      if (!this._validate(attrs, options)) return false;\n\n      // Extract attributes and options.\n      unset           = options.unset;\n      silent          = options.silent;\n      changes         = [];\n      changing        = this._changing;\n      this._changing  = true;\n\n      if (!changing) {\n        this._previousAttributes = _.clone(this.attributes);\n        this.changed = {};\n      }\n      current = this.attributes, prev = this._previousAttributes;\n\n      // Check for changes of `id`.\n      if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];\n\n      // For each `set` attribute, update or delete the current value.\n      for (attr in attrs) {\n        val = attrs[attr];\n        if (!_.isEqual(current[attr], val)) changes.push(attr);\n        if (!_.isEqual(prev[attr], val)) {\n          this.changed[attr] = val;\n        } else {\n          delete this.changed[attr];\n        }\n        unset ? delete current[attr] : current[attr] = val;\n      }\n\n      // Trigger all relevant attribute changes.\n      if (!silent) {\n        if (changes.length) this._pending = options;\n        for (var i = 0, l = changes.length; i < l; i++) {\n          this.trigger('change:' + changes[i], this, current[changes[i]], options);\n        }\n      }\n\n      // You might be wondering why there's a `while` loop here. Changes can\n      // be recursively nested within `\"change\"` events.\n      if (changing) return this;\n      if (!silent) {\n        while (this._pending) {\n          options = this._pending;\n          this._pending = false;\n          this.trigger('change', this, options);\n        }\n      }\n      this._pending = false;\n      this._changing = false;\n      return this;\n    },\n\n    // Remove an attribute from the model, firing `\"change\"`. `unset` is a noop\n    // if the attribute doesn't exist.\n    unset: function(attr, options) {\n      return this.set(attr, void 0, _.extend({}, options, {unset: true}));\n    },\n\n    // Clear all attributes on the model, firing `\"change\"`.\n    clear: function(options) {\n      var attrs = {};\n      for (var key in this.attributes) attrs[key] = void 0;\n      return this.set(attrs, _.extend({}, options, {unset: true}));\n    },\n\n    // Determine if the model has changed since the last `\"change\"` event.\n    // If you specify an attribute name, determine if that attribute has changed.\n    hasChanged: function(attr) {\n      if (attr == null) return !_.isEmpty(this.changed);\n      return _.has(this.changed, attr);\n    },\n\n    // Return an object containing all the attributes that have changed, or\n    // false if there are no changed attributes. Useful for determining what\n    // parts of a view need to be updated and/or what attributes need to be\n    // persisted to the server. Unset attributes will be set to undefined.\n    // You can also pass an attributes object to diff against the model,\n    // determining if there *would be* a change.\n    changedAttributes: function(diff) {\n      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;\n      var val, changed = false;\n      var old = this._changing ? this._previousAttributes : this.attributes;\n      for (var attr in diff) {\n        if (_.isEqual(old[attr], (val = diff[attr]))) continue;\n        (changed || (changed = {}))[attr] = val;\n      }\n      return changed;\n    },\n\n    // Get the previous value of an attribute, recorded at the time the last\n    // `\"change\"` event was fired.\n    previous: function(attr) {\n      if (attr == null || !this._previousAttributes) return null;\n      return this._previousAttributes[attr];\n    },\n\n    // Get all of the attributes of the model at the time of the previous\n    // `\"change\"` event.\n    previousAttributes: function() {\n      return _.clone(this._previousAttributes);\n    },\n\n    // Fetch the model from the server. If the server's representation of the\n    // model differs from its current attributes, they will be overridden,\n    // triggering a `\"change\"` event.\n    fetch: function(options) {\n      options = options ? _.clone(options) : {};\n      if (options.parse === void 0) options.parse = true;\n      var model = this;\n      var success = options.success;\n      options.success = function(resp) {\n        if (!model.set(model.parse(resp, options), options)) return false;\n        if (success) success(model, resp, options);\n        model.trigger('sync', model, resp, options);\n      };\n      wrapError(this, options);\n      return this.sync('read', this, options);\n    },\n\n    // Set a hash of model attributes, and sync the model to the server.\n    // If the server returns an attributes hash that differs, the model's\n    // state will be `set` again.\n    save: function(key, val, options) {\n      var attrs, method, xhr, attributes = this.attributes;\n\n      // Handle both `\"key\", value` and `{key: value}` -style arguments.\n      if (key == null || typeof key === 'object') {\n        attrs = key;\n        options = val;\n      } else {\n        (attrs = {})[key] = val;\n      }\n\n      options = _.extend({validate: true}, options);\n\n      // If we're not waiting and attributes exist, save acts as\n      // `set(attr).save(null, opts)` with validation. Otherwise, check if\n      // the model will be valid when the attributes, if any, are set.\n      if (attrs && !options.wait) {\n        if (!this.set(attrs, options)) return false;\n      } else {\n        if (!this._validate(attrs, options)) return false;\n      }\n\n      // Set temporary attributes if `{wait: true}`.\n      if (attrs && options.wait) {\n        this.attributes = _.extend({}, attributes, attrs);\n      }\n\n      // After a successful server-side save, the client is (optionally)\n      // updated with the server-side state.\n      if (options.parse === void 0) options.parse = true;\n      var model = this;\n      var success = options.success;\n      options.success = function(resp) {\n        // Ensure attributes are restored during synchronous saves.\n        model.attributes = attributes;\n        var serverAttrs = model.parse(resp, options);\n        if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);\n        if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {\n          return false;\n        }\n        if (success) success(model, resp, options);\n        model.trigger('sync', model, resp, options);\n      };\n      wrapError(this, options);\n\n      method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');\n      if (method === 'patch') options.attrs = attrs;\n      xhr = this.sync(method, this, options);\n\n      // Restore attributes.\n      if (attrs && options.wait) this.attributes = attributes;\n\n      return xhr;\n    },\n\n    // Destroy this model on the server if it was already persisted.\n    // Optimistically removes the model from its collection, if it has one.\n    // If `wait: true` is passed, waits for the server to respond before removal.\n    destroy: function(options) {\n      options = options ? _.clone(options) : {};\n      var model = this;\n      var success = options.success;\n\n      var destroy = function() {\n        model.trigger('destroy', model, model.collection, options);\n      };\n\n      options.success = function(resp) {\n        if (options.wait || model.isNew()) destroy();\n        if (success) success(model, resp, options);\n        if (!model.isNew()) model.trigger('sync', model, resp, options);\n      };\n\n      if (this.isNew()) {\n        options.success();\n        return false;\n      }\n      wrapError(this, options);\n\n      var xhr = this.sync('delete', this, options);\n      if (!options.wait) destroy();\n      return xhr;\n    },\n\n    // Default URL for the model's representation on the server -- if you're\n    // using Backbone's restful methods, override this to change the endpoint\n    // that will be called.\n    url: function() {\n      var base =\n        _.result(this, 'urlRoot') ||\n        _.result(this.collection, 'url') ||\n        urlError();\n      if (this.isNew()) return base;\n      return base.replace(/([^\\/])$/, '$1/') + encodeURIComponent(this.id);\n    },\n\n    // **parse** converts a response into the hash of attributes to be `set` on\n    // the model. The default implementation is just to pass the response along.\n    parse: function(resp, options) {\n      return resp;\n    },\n\n    // Create a new model with identical attributes to this one.\n    clone: function() {\n      return new this.constructor(this.attributes);\n    },\n\n    // A model is new if it has never been saved to the server, and lacks an id.\n    isNew: function() {\n      return !this.has(this.idAttribute);\n    },\n\n    // Check if the model is currently in a valid state.\n    isValid: function(options) {\n      return this._validate({}, _.extend(options || {}, { validate: true }));\n    },\n\n    // Run validation against the next complete set of model attributes,\n    // returning `true` if all is well. Otherwise, fire an `\"invalid\"` event.\n    _validate: function(attrs, options) {\n      if (!options.validate || !this.validate) return true;\n      attrs = _.extend({}, this.attributes, attrs);\n      var error = this.validationError = this.validate(attrs, options) || null;\n      if (!error) return true;\n      this.trigger('invalid', this, error, _.extend(options, {validationError: error}));\n      return false;\n    }\n\n  });\n\n  // Underscore methods that we want to implement on the Model.\n  var modelMethods = ['keys', 'values', 'pairs', 'invert', 'pick', 'omit'];\n\n  // Mix in each Underscore method as a proxy to `Model#attributes`.\n  _.each(modelMethods, function(method) {\n    Model.prototype[method] = function() {\n      var args = slice.call(arguments);\n      args.unshift(this.attributes);\n      return _[method].apply(_, args);\n    };\n  });\n\n  // Backbone.Collection\n  // -------------------\n\n  // If models tend to represent a single row of data, a Backbone Collection is\n  // more analagous to a table full of data ... or a small slice or page of that\n  // table, or a collection of rows that belong together for a particular reason\n  // -- all of the messages in this particular folder, all of the documents\n  // belonging to this particular author, and so on. Collections maintain\n  // indexes of their models, both in order, and for lookup by `id`.\n\n  // Create a new **Collection**, perhaps to contain a specific type of `model`.\n  // If a `comparator` is specified, the Collection will maintain\n  // its models in sort order, as they're added and removed.\n  var Collection = Backbone.Collection = function(models, options) {\n    options || (options = {});\n    if (options.model) this.model = options.model;\n    if (options.comparator !== void 0) this.comparator = options.comparator;\n    this._reset();\n    this.initialize.apply(this, arguments);\n    if (models) this.reset(models, _.extend({silent: true}, options));\n  };\n\n  // Default options for `Collection#set`.\n  var setOptions = {add: true, remove: true, merge: true};\n  var addOptions = {add: true, remove: false};\n\n  // Define the Collection's inheritable methods.\n  _.extend(Collection.prototype, Events, {\n\n    // The default model for a collection is just a **Backbone.Model**.\n    // This should be overridden in most cases.\n    model: Model,\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){},\n\n    // The JSON representation of a Collection is an array of the\n    // models' attributes.\n    toJSON: function(options) {\n      return this.map(function(model){ return model.toJSON(options); });\n    },\n\n    // Proxy `Backbone.sync` by default.\n    sync: function() {\n      return Backbone.sync.apply(this, arguments);\n    },\n\n    // Add a model, or list of models to the set.\n    add: function(models, options) {\n      return this.set(models, _.extend({merge: false}, options, addOptions));\n    },\n\n    // Remove a model, or a list of models from the set.\n    remove: function(models, options) {\n      var singular = !_.isArray(models);\n      models = singular ? [models] : _.clone(models);\n      options || (options = {});\n      var i, l, index, model;\n      for (i = 0, l = models.length; i < l; i++) {\n        model = models[i] = this.get(models[i]);\n        if (!model) continue;\n        delete this._byId[model.id];\n        delete this._byId[model.cid];\n        index = this.indexOf(model);\n        this.models.splice(index, 1);\n        this.length--;\n        if (!options.silent) {\n          options.index = index;\n          model.trigger('remove', model, this, options);\n        }\n        this._removeReference(model, options);\n      }\n      return singular ? models[0] : models;\n    },\n\n    // Update a collection by `set`-ing a new list of models, adding new ones,\n    // removing models that are no longer present, and merging models that\n    // already exist in the collection, as necessary. Similar to **Model#set**,\n    // the core operation for updating the data contained by the collection.\n    set: function(models, options) {\n      options = _.defaults({}, options, setOptions);\n      if (options.parse) models = this.parse(models, options);\n      var singular = !_.isArray(models);\n      models = singular ? (models ? [models] : []) : _.clone(models);\n      var i, l, id, model, attrs, existing, sort;\n      var at = options.at;\n      var targetModel = this.model;\n      var sortable = this.comparator && (at == null) && options.sort !== false;\n      var sortAttr = _.isString(this.comparator) ? this.comparator : null;\n      var toAdd = [], toRemove = [], modelMap = {};\n      var add = options.add, merge = options.merge, remove = options.remove;\n      var order = !sortable && add && remove ? [] : false;\n\n      // Turn bare objects into model references, and prevent invalid models\n      // from being added.\n      for (i = 0, l = models.length; i < l; i++) {\n        attrs = models[i] || {};\n        if (attrs instanceof Model) {\n          id = model = attrs;\n        } else {\n          id = attrs[targetModel.prototype.idAttribute || 'id'];\n        }\n\n        // If a duplicate is found, prevent it from being added and\n        // optionally merge it into the existing model.\n        if (existing = this.get(id)) {\n          if (remove) modelMap[existing.cid] = true;\n          if (merge) {\n            attrs = attrs === model ? model.attributes : attrs;\n            if (options.parse) attrs = existing.parse(attrs, options);\n            existing.set(attrs, options);\n            if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;\n          }\n          models[i] = existing;\n\n        // If this is a new, valid model, push it to the `toAdd` list.\n        } else if (add) {\n          model = models[i] = this._prepareModel(attrs, options);\n          if (!model) continue;\n          toAdd.push(model);\n          this._addReference(model, options);\n        }\n\n        // Do not add multiple models with the same `id`.\n        model = existing || model;\n        if (order && (model.isNew() || !modelMap[model.id])) order.push(model);\n        modelMap[model.id] = true;\n      }\n\n      // Remove nonexistent models if appropriate.\n      if (remove) {\n        for (i = 0, l = this.length; i < l; ++i) {\n          if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);\n        }\n        if (toRemove.length) this.remove(toRemove, options);\n      }\n\n      // See if sorting is needed, update `length` and splice in new models.\n      if (toAdd.length || (order && order.length)) {\n        if (sortable) sort = true;\n        this.length += toAdd.length;\n        if (at != null) {\n          for (i = 0, l = toAdd.length; i < l; i++) {\n            this.models.splice(at + i, 0, toAdd[i]);\n          }\n        } else {\n          if (order) this.models.length = 0;\n          var orderedModels = order || toAdd;\n          for (i = 0, l = orderedModels.length; i < l; i++) {\n            this.models.push(orderedModels[i]);\n          }\n        }\n      }\n\n      // Silently sort the collection if appropriate.\n      if (sort) this.sort({silent: true});\n\n      // Unless silenced, it's time to fire all appropriate add/sort events.\n      if (!options.silent) {\n        for (i = 0, l = toAdd.length; i < l; i++) {\n          (model = toAdd[i]).trigger('add', model, this, options);\n        }\n        if (sort || (order && order.length)) this.trigger('sort', this, options);\n      }\n\n      // Return the added (or merged) model (or models).\n      return singular ? models[0] : models;\n    },\n\n    // When you have more items than you want to add or remove individually,\n    // you can reset the entire set with a new list of models, without firing\n    // any granular `add` or `remove` events. Fires `reset` when finished.\n    // Useful for bulk operations and optimizations.\n    reset: function(models, options) {\n      options || (options = {});\n      for (var i = 0, l = this.models.length; i < l; i++) {\n        this._removeReference(this.models[i], options);\n      }\n      options.previousModels = this.models;\n      this._reset();\n      models = this.add(models, _.extend({silent: true}, options));\n      if (!options.silent) this.trigger('reset', this, options);\n      return models;\n    },\n\n    // Add a model to the end of the collection.\n    push: function(model, options) {\n      return this.add(model, _.extend({at: this.length}, options));\n    },\n\n    // Remove a model from the end of the collection.\n    pop: function(options) {\n      var model = this.at(this.length - 1);\n      this.remove(model, options);\n      return model;\n    },\n\n    // Add a model to the beginning of the collection.\n    unshift: function(model, options) {\n      return this.add(model, _.extend({at: 0}, options));\n    },\n\n    // Remove a model from the beginning of the collection.\n    shift: function(options) {\n      var model = this.at(0);\n      this.remove(model, options);\n      return model;\n    },\n\n    // Slice out a sub-array of models from the collection.\n    slice: function() {\n      return slice.apply(this.models, arguments);\n    },\n\n    // Get a model from the set by id.\n    get: function(obj) {\n      if (obj == null) return void 0;\n      return this._byId[obj] || this._byId[obj.id] || this._byId[obj.cid];\n    },\n\n    // Get the model at the given index.\n    at: function(index) {\n      return this.models[index];\n    },\n\n    // Return models with matching attributes. Useful for simple cases of\n    // `filter`.\n    where: function(attrs, first) {\n      if (_.isEmpty(attrs)) return first ? void 0 : [];\n      return this[first ? 'find' : 'filter'](function(model) {\n        for (var key in attrs) {\n          if (attrs[key] !== model.get(key)) return false;\n        }\n        return true;\n      });\n    },\n\n    // Return the first model with matching attributes. Useful for simple cases\n    // of `find`.\n    findWhere: function(attrs) {\n      return this.where(attrs, true);\n    },\n\n    // Force the collection to re-sort itself. You don't need to call this under\n    // normal circumstances, as the set will maintain sort order as each item\n    // is added.\n    sort: function(options) {\n      if (!this.comparator) throw new Error('Cannot sort a set without a comparator');\n      options || (options = {});\n\n      // Run sort based on type of `comparator`.\n      if (_.isString(this.comparator) || this.comparator.length === 1) {\n        this.models = this.sortBy(this.comparator, this);\n      } else {\n        this.models.sort(_.bind(this.comparator, this));\n      }\n\n      if (!options.silent) this.trigger('sort', this, options);\n      return this;\n    },\n\n    // Pluck an attribute from each model in the collection.\n    pluck: function(attr) {\n      return _.invoke(this.models, 'get', attr);\n    },\n\n    // Fetch the default set of models for this collection, resetting the\n    // collection when they arrive. If `reset: true` is passed, the response\n    // data will be passed through the `reset` method instead of `set`.\n    fetch: function(options) {\n      options = options ? _.clone(options) : {};\n      if (options.parse === void 0) options.parse = true;\n      var success = options.success;\n      var collection = this;\n      options.success = function(resp) {\n        var method = options.reset ? 'reset' : 'set';\n        collection[method](resp, options);\n        if (success) success(collection, resp, options);\n        collection.trigger('sync', collection, resp, options);\n      };\n      wrapError(this, options);\n      return this.sync('read', this, options);\n    },\n\n    // Create a new instance of a model in this collection. Add the model to the\n    // collection immediately, unless `wait: true` is passed, in which case we\n    // wait for the server to agree.\n    create: function(model, options) {\n      options = options ? _.clone(options) : {};\n      if (!(model = this._prepareModel(model, options))) return false;\n      if (!options.wait) this.add(model, options);\n      var collection = this;\n      var success = options.success;\n      options.success = function(model, resp) {\n        if (options.wait) collection.add(model, options);\n        if (success) success(model, resp, options);\n      };\n      model.save(null, options);\n      return model;\n    },\n\n    // **parse** converts a response into a list of models to be added to the\n    // collection. The default implementation is just to pass it through.\n    parse: function(resp, options) {\n      return resp;\n    },\n\n    // Create a new collection with an identical list of models as this one.\n    clone: function() {\n      return new this.constructor(this.models);\n    },\n\n    // Private method to reset all internal state. Called when the collection\n    // is first initialized or reset.\n    _reset: function() {\n      this.length = 0;\n      this.models = [];\n      this._byId  = {};\n    },\n\n    // Prepare a hash of attributes (or other model) to be added to this\n    // collection.\n    _prepareModel: function(attrs, options) {\n      if (attrs instanceof Model) return attrs;\n      options = options ? _.clone(options) : {};\n      options.collection = this;\n      var model = new this.model(attrs, options);\n      if (!model.validationError) return model;\n      this.trigger('invalid', this, model.validationError, options);\n      return false;\n    },\n\n    // Internal method to create a model's ties to a collection.\n    _addReference: function(model, options) {\n      this._byId[model.cid] = model;\n      if (model.id != null) this._byId[model.id] = model;\n      if (!model.collection) model.collection = this;\n      model.on('all', this._onModelEvent, this);\n    },\n\n    // Internal method to sever a model's ties to a collection.\n    _removeReference: function(model, options) {\n      if (this === model.collection) delete model.collection;\n      model.off('all', this._onModelEvent, this);\n    },\n\n    // Internal method called every time a model in the set fires an event.\n    // Sets need to update their indexes when models change ids. All other\n    // events simply proxy through. \"add\" and \"remove\" events that originate\n    // in other collections are ignored.\n    _onModelEvent: function(event, model, collection, options) {\n      if ((event === 'add' || event === 'remove') && collection !== this) return;\n      if (event === 'destroy') this.remove(model, options);\n      if (model && event === 'change:' + model.idAttribute) {\n        delete this._byId[model.previous(model.idAttribute)];\n        if (model.id != null) this._byId[model.id] = model;\n      }\n      this.trigger.apply(this, arguments);\n    }\n\n  });\n\n  // Underscore methods that we want to implement on the Collection.\n  // 90% of the core usefulness of Backbone Collections is actually implemented\n  // right here:\n  var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl',\n    'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select',\n    'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke',\n    'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest',\n    'tail', 'drop', 'last', 'without', 'difference', 'indexOf', 'shuffle',\n    'lastIndexOf', 'isEmpty', 'chain', 'sample'];\n\n  // Mix in each Underscore method as a proxy to `Collection#models`.\n  _.each(methods, function(method) {\n    Collection.prototype[method] = function() {\n      var args = slice.call(arguments);\n      args.unshift(this.models);\n      return _[method].apply(_, args);\n    };\n  });\n\n  // Underscore methods that take a property name as an argument.\n  var attributeMethods = ['groupBy', 'countBy', 'sortBy', 'indexBy'];\n\n  // Use attributes instead of properties.\n  _.each(attributeMethods, function(method) {\n    Collection.prototype[method] = function(value, context) {\n      var iterator = _.isFunction(value) ? value : function(model) {\n        return model.get(value);\n      };\n      return _[method](this.models, iterator, context);\n    };\n  });\n\n  // Backbone.View\n  // -------------\n\n  // Backbone Views are almost more convention than they are actual code. A View\n  // is simply a JavaScript object that represents a logical chunk of UI in the\n  // DOM. This might be a single item, an entire list, a sidebar or panel, or\n  // even the surrounding frame which wraps your whole app. Defining a chunk of\n  // UI as a **View** allows you to define your DOM events declaratively, without\n  // having to worry about render order ... and makes it easy for the view to\n  // react to specific changes in the state of your models.\n\n  // Creating a Backbone.View creates its initial element outside of the DOM,\n  // if an existing element is not provided...\n  var View = Backbone.View = function(options) {\n    this.cid = _.uniqueId('view');\n    options || (options = {});\n    _.extend(this, _.pick(options, viewOptions));\n    this._ensureElement();\n    this.initialize.apply(this, arguments);\n    this.delegateEvents();\n  };\n\n  // Cached regex to split keys for `delegate`.\n  var delegateEventSplitter = /^(\\S+)\\s*(.*)$/;\n\n  // List of view options to be merged as properties.\n  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];\n\n  // Set up all inheritable **Backbone.View** properties and methods.\n  _.extend(View.prototype, Events, {\n\n    // The default `tagName` of a View's element is `\"div\"`.\n    tagName: 'div',\n\n    // jQuery delegate for element lookup, scoped to DOM elements within the\n    // current view. This should be preferred to global lookups where possible.\n    $: function(selector) {\n      return this.$el.find(selector);\n    },\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){},\n\n    // **render** is the core function that your view should override, in order\n    // to populate its element (`this.el`), with the appropriate HTML. The\n    // convention is for **render** to always return `this`.\n    render: function() {\n      return this;\n    },\n\n    // Remove this view by taking the element out of the DOM, and removing any\n    // applicable Backbone.Events listeners.\n    remove: function() {\n      this.$el.remove();\n      this.stopListening();\n      return this;\n    },\n\n    // Change the view's element (`this.el` property), including event\n    // re-delegation.\n    setElement: function(element, delegate) {\n      if (this.$el) this.undelegateEvents();\n      this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);\n      this.el = this.$el[0];\n      if (delegate !== false) this.delegateEvents();\n      return this;\n    },\n\n    // Set callbacks, where `this.events` is a hash of\n    //\n    // *{\"event selector\": \"callback\"}*\n    //\n    //     {\n    //       'mousedown .title':  'edit',\n    //       'click .button':     'save',\n    //       'click .open':       function(e) { ... }\n    //     }\n    //\n    // pairs. Callbacks will be bound to the view, with `this` set properly.\n    // Uses event delegation for efficiency.\n    // Omitting the selector binds the event to `this.el`.\n    // This only works for delegate-able events: not `focus`, `blur`, and\n    // not `change`, `submit`, and `reset` in Internet Explorer.\n    delegateEvents: function(events) {\n      if (!(events || (events = _.result(this, 'events')))) return this;\n      this.undelegateEvents();\n      for (var key in events) {\n        var method = events[key];\n        if (!_.isFunction(method)) method = this[events[key]];\n        if (!method) continue;\n\n        var match = key.match(delegateEventSplitter);\n        var eventName = match[1], selector = match[2];\n        method = _.bind(method, this);\n        eventName += '.delegateEvents' + this.cid;\n        if (selector === '') {\n          this.$el.on(eventName, method);\n        } else {\n          this.$el.on(eventName, selector, method);\n        }\n      }\n      return this;\n    },\n\n    // Clears all callbacks previously bound to the view with `delegateEvents`.\n    // You usually don't need to use this, but may wish to if you have multiple\n    // Backbone views attached to the same DOM element.\n    undelegateEvents: function() {\n      this.$el.off('.delegateEvents' + this.cid);\n      return this;\n    },\n\n    // Ensure that the View has a DOM element to render into.\n    // If `this.el` is a string, pass it through `$()`, take the first\n    // matching element, and re-assign it to `el`. Otherwise, create\n    // an element from the `id`, `className` and `tagName` properties.\n    _ensureElement: function() {\n      if (!this.el) {\n        var attrs = _.extend({}, _.result(this, 'attributes'));\n        if (this.id) attrs.id = _.result(this, 'id');\n        if (this.className) attrs['class'] = _.result(this, 'className');\n        var $el = Backbone.$('<' + _.result(this, 'tagName') + '>').attr(attrs);\n        this.setElement($el, false);\n      } else {\n        this.setElement(_.result(this, 'el'), false);\n      }\n    }\n\n  });\n\n  // Backbone.sync\n  // -------------\n\n  // Override this function to change the manner in which Backbone persists\n  // models to the server. You will be passed the type of request, and the\n  // model in question. By default, makes a RESTful Ajax request\n  // to the model's `url()`. Some possible customizations could be:\n  //\n  // * Use `setTimeout` to batch rapid-fire updates into a single request.\n  // * Send up the models as XML instead of JSON.\n  // * Persist models via WebSockets instead of Ajax.\n  //\n  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests\n  // as `POST`, with a `_method` parameter containing the true HTTP method,\n  // as well as all requests with the body as `application/x-www-form-urlencoded`\n  // instead of `application/json` with the model in a param named `model`.\n  // Useful when interfacing with server-side languages like **PHP** that make\n  // it difficult to read the body of `PUT` requests.\n  Backbone.sync = function(method, model, options) {\n    var type = methodMap[method];\n\n    // Default options, unless specified.\n    _.defaults(options || (options = {}), {\n      emulateHTTP: Backbone.emulateHTTP,\n      emulateJSON: Backbone.emulateJSON\n    });\n\n    // Default JSON-request options.\n    var params = {type: type, dataType: 'json'};\n\n    // Ensure that we have a URL.\n    if (!options.url) {\n      params.url = _.result(model, 'url') || urlError();\n    }\n\n    // Ensure that we have the appropriate request data.\n    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {\n      params.contentType = 'application/json';\n      params.data = JSON.stringify(options.attrs || model.toJSON(options));\n    }\n\n    // For older servers, emulate JSON by encoding the request into an HTML-form.\n    if (options.emulateJSON) {\n      params.contentType = 'application/x-www-form-urlencoded';\n      params.data = params.data ? {model: params.data} : {};\n    }\n\n    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`\n    // And an `X-HTTP-Method-Override` header.\n    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {\n      params.type = 'POST';\n      if (options.emulateJSON) params.data._method = type;\n      var beforeSend = options.beforeSend;\n      options.beforeSend = function(xhr) {\n        xhr.setRequestHeader('X-HTTP-Method-Override', type);\n        if (beforeSend) return beforeSend.apply(this, arguments);\n      };\n    }\n\n    // Don't process data on a non-GET request.\n    if (params.type !== 'GET' && !options.emulateJSON) {\n      params.processData = false;\n    }\n\n    // If we're sending a `PATCH` request, and we're in an old Internet Explorer\n    // that still has ActiveX enabled by default, override jQuery to use that\n    // for XHR instead. Remove this line when jQuery supports `PATCH` on IE8.\n    if (params.type === 'PATCH' && noXhrPatch) {\n      params.xhr = function() {\n        return new ActiveXObject(\"Microsoft.XMLHTTP\");\n      };\n    }\n\n    // Make the request, allowing the user to override any Ajax options.\n    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));\n    model.trigger('request', model, xhr, options);\n    return xhr;\n  };\n\n  var noXhrPatch =\n    typeof window !== 'undefined' && !!window.ActiveXObject &&\n      !(window.XMLHttpRequest && (new XMLHttpRequest).dispatchEvent);\n\n  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.\n  var methodMap = {\n    'create': 'POST',\n    'update': 'PUT',\n    'patch':  'PATCH',\n    'delete': 'DELETE',\n    'read':   'GET'\n  };\n\n  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.\n  // Override this if you'd like to use a different library.\n  Backbone.ajax = function() {\n    return Backbone.$.ajax.apply(Backbone.$, arguments);\n  };\n\n  // Backbone.Router\n  // ---------------\n\n  // Routers map faux-URLs to actions, and fire events when routes are\n  // matched. Creating a new one sets its `routes` hash, if not set statically.\n  var Router = Backbone.Router = function(options) {\n    options || (options = {});\n    if (options.routes) this.routes = options.routes;\n    this._bindRoutes();\n    this.initialize.apply(this, arguments);\n  };\n\n  // Cached regular expressions for matching named param parts and splatted\n  // parts of route strings.\n  var optionalParam = /\\((.*?)\\)/g;\n  var namedParam    = /(\\(\\?)?:\\w+/g;\n  var splatParam    = /\\*\\w+/g;\n  var escapeRegExp  = /[\\-{}\\[\\]+?.,\\\\\\^$|#\\s]/g;\n\n  // Set up all inheritable **Backbone.Router** properties and methods.\n  _.extend(Router.prototype, Events, {\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){},\n\n    // Manually bind a single named route to a callback. For example:\n    //\n    //     this.route('search/:query/p:num', 'search', function(query, num) {\n    //       ...\n    //     });\n    //\n    route: function(route, name, callback) {\n      if (!_.isRegExp(route)) route = this._routeToRegExp(route);\n      if (_.isFunction(name)) {\n        callback = name;\n        name = '';\n      }\n      if (!callback) callback = this[name];\n      var router = this;\n      Backbone.history.route(route, function(fragment) {\n        var args = router._extractParameters(route, fragment);\n        router.execute(callback, args);\n        router.trigger.apply(router, ['route:' + name].concat(args));\n        router.trigger('route', name, args);\n        Backbone.history.trigger('route', router, name, args);\n      });\n      return this;\n    },\n\n    // Execute a route handler with the provided parameters.  This is an\n    // excellent place to do pre-route setup or post-route cleanup.\n    execute: function(callback, args) {\n      if (callback) callback.apply(this, args);\n    },\n\n    // Simple proxy to `Backbone.history` to save a fragment into the history.\n    navigate: function(fragment, options) {\n      Backbone.history.navigate(fragment, options);\n      return this;\n    },\n\n    // Bind all defined routes to `Backbone.history`. We have to reverse the\n    // order of the routes here to support behavior where the most general\n    // routes can be defined at the bottom of the route map.\n    _bindRoutes: function() {\n      if (!this.routes) return;\n      this.routes = _.result(this, 'routes');\n      var route, routes = _.keys(this.routes);\n      while ((route = routes.pop()) != null) {\n        this.route(route, this.routes[route]);\n      }\n    },\n\n    // Convert a route string into a regular expression, suitable for matching\n    // against the current location hash.\n    _routeToRegExp: function(route) {\n      route = route.replace(escapeRegExp, '\\\\$&')\n                   .replace(optionalParam, '(?:$1)?')\n                   .replace(namedParam, function(match, optional) {\n                     return optional ? match : '([^/?]+)';\n                   })\n                   .replace(splatParam, '([^?]*?)');\n      return new RegExp('^' + route + '(?:\\\\?([\\\\s\\\\S]*))?$');\n    },\n\n    // Given a route, and a URL fragment that it matches, return the array of\n    // extracted decoded parameters. Empty or unmatched parameters will be\n    // treated as `null` to normalize cross-browser behavior.\n    _extractParameters: function(route, fragment) {\n      var params = route.exec(fragment).slice(1);\n      return _.map(params, function(param, i) {\n        // Don't decode the search params.\n        if (i === params.length - 1) return param || null;\n        return param ? decodeURIComponent(param) : null;\n      });\n    }\n\n  });\n\n  // Backbone.History\n  // ----------------\n\n  // Handles cross-browser history management, based on either\n  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or\n  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)\n  // and URL fragments. If the browser supports neither (old IE, natch),\n  // falls back to polling.\n  var History = Backbone.History = function() {\n    this.handlers = [];\n    _.bindAll(this, 'checkUrl');\n\n    // Ensure that `History` can be used outside of the browser.\n    if (typeof window !== 'undefined') {\n      this.location = window.location;\n      this.history = window.history;\n    }\n  };\n\n  // Cached regex for stripping a leading hash/slash and trailing space.\n  var routeStripper = /^[#\\/]|\\s+$/g;\n\n  // Cached regex for stripping leading and trailing slashes.\n  var rootStripper = /^\\/+|\\/+$/g;\n\n  // Cached regex for detecting MSIE.\n  var isExplorer = /msie [\\w.]+/;\n\n  // Cached regex for removing a trailing slash.\n  var trailingSlash = /\\/$/;\n\n  // Cached regex for stripping urls of hash.\n  var pathStripper = /#.*$/;\n\n  // Has the history handling already been started?\n  History.started = false;\n\n  // Set up all inheritable **Backbone.History** properties and methods.\n  _.extend(History.prototype, Events, {\n\n    // The default interval to poll for hash changes, if necessary, is\n    // twenty times a second.\n    interval: 50,\n\n    // Are we at the app root?\n    atRoot: function() {\n      return this.location.pathname.replace(/[^\\/]$/, '$&/') === this.root;\n    },\n\n    // Gets the true hash value. Cannot use location.hash directly due to bug\n    // in Firefox where location.hash will always be decoded.\n    getHash: function(window) {\n      var match = (window || this).location.href.match(/#(.*)$/);\n      return match ? match[1] : '';\n    },\n\n    // Get the cross-browser normalized URL fragment, either from the URL,\n    // the hash, or the override.\n    getFragment: function(fragment, forcePushState) {\n      if (fragment == null) {\n        if (this._hasPushState || !this._wantsHashChange || forcePushState) {\n          fragment = decodeURI(this.location.pathname + this.location.search);\n          var root = this.root.replace(trailingSlash, '');\n          if (!fragment.indexOf(root)) fragment = fragment.slice(root.length);\n        } else {\n          fragment = this.getHash();\n        }\n      }\n      return fragment.replace(routeStripper, '');\n    },\n\n    // Start the hash change handling, returning `true` if the current URL matches\n    // an existing route, and `false` otherwise.\n    start: function(options) {\n      if (History.started) throw new Error(\"Backbone.history has already been started\");\n      History.started = true;\n\n      // Figure out the initial configuration. Do we need an iframe?\n      // Is pushState desired ... is it available?\n      this.options          = _.extend({root: '/'}, this.options, options);\n      this.root             = this.options.root;\n      this._wantsHashChange = this.options.hashChange !== false;\n      this._wantsPushState  = !!this.options.pushState;\n      this._hasPushState    = !!(this.options.pushState && this.history && this.history.pushState);\n      var fragment          = this.getFragment();\n      var docMode           = document.documentMode;\n      var oldIE             = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));\n\n      // Normalize root to always include a leading and trailing slash.\n      this.root = ('/' + this.root + '/').replace(rootStripper, '/');\n\n      if (oldIE && this._wantsHashChange) {\n        var frame = Backbone.$('<iframe src=\"javascript:0\" tabindex=\"-1\">');\n        this.iframe = frame.hide().appendTo('body')[0].contentWindow;\n        this.navigate(fragment);\n      }\n\n      // Depending on whether we're using pushState or hashes, and whether\n      // 'onhashchange' is supported, determine how we check the URL state.\n      if (this._hasPushState) {\n        Backbone.$(window).on('popstate', this.checkUrl);\n      } else if (this._wantsHashChange && ('onhashchange' in window) && !oldIE) {\n        Backbone.$(window).on('hashchange', this.checkUrl);\n      } else if (this._wantsHashChange) {\n        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);\n      }\n\n      // Determine if we need to change the base url, for a pushState link\n      // opened by a non-pushState browser.\n      this.fragment = fragment;\n      var loc = this.location;\n\n      // Transition from hashChange to pushState or vice versa if both are\n      // requested.\n      if (this._wantsHashChange && this._wantsPushState) {\n\n        // If we've started off with a route from a `pushState`-enabled\n        // browser, but we're currently in a browser that doesn't support it...\n        if (!this._hasPushState && !this.atRoot()) {\n          this.fragment = this.getFragment(null, true);\n          this.location.replace(this.root + '#' + this.fragment);\n          // Return immediately as browser will do redirect to new url\n          return true;\n\n        // Or if we've started out with a hash-based route, but we're currently\n        // in a browser where it could be `pushState`-based instead...\n        } else if (this._hasPushState && this.atRoot() && loc.hash) {\n          this.fragment = this.getHash().replace(routeStripper, '');\n          this.history.replaceState({}, document.title, this.root + this.fragment);\n        }\n\n      }\n\n      if (!this.options.silent) return this.loadUrl();\n    },\n\n    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,\n    // but possibly useful for unit testing Routers.\n    stop: function() {\n      Backbone.$(window).off('popstate', this.checkUrl).off('hashchange', this.checkUrl);\n      if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);\n      History.started = false;\n    },\n\n    // Add a route to be tested when the fragment changes. Routes added later\n    // may override previous routes.\n    route: function(route, callback) {\n      this.handlers.unshift({route: route, callback: callback});\n    },\n\n    // Checks the current URL to see if it has changed, and if it has,\n    // calls `loadUrl`, normalizing across the hidden iframe.\n    checkUrl: function(e) {\n      var current = this.getFragment();\n      if (current === this.fragment && this.iframe) {\n        current = this.getFragment(this.getHash(this.iframe));\n      }\n      if (current === this.fragment) return false;\n      if (this.iframe) this.navigate(current);\n      this.loadUrl();\n    },\n\n    // Attempt to load the current URL fragment. If a route succeeds with a\n    // match, returns `true`. If no defined routes matches the fragment,\n    // returns `false`.\n    loadUrl: function(fragment) {\n      fragment = this.fragment = this.getFragment(fragment);\n      return _.any(this.handlers, function(handler) {\n        if (handler.route.test(fragment)) {\n          handler.callback(fragment);\n          return true;\n        }\n      });\n    },\n\n    // Save a fragment into the hash history, or replace the URL state if the\n    // 'replace' option is passed. You are responsible for properly URL-encoding\n    // the fragment in advance.\n    //\n    // The options object can contain `trigger: true` if you wish to have the\n    // route callback be fired (not usually desirable), or `replace: true`, if\n    // you wish to modify the current URL without adding an entry to the history.\n    navigate: function(fragment, options) {\n      if (!History.started) return false;\n      if (!options || options === true) options = {trigger: !!options};\n\n      var url = this.root + (fragment = this.getFragment(fragment || ''));\n\n      // Strip the hash for matching.\n      fragment = fragment.replace(pathStripper, '');\n\n      if (this.fragment === fragment) return;\n      this.fragment = fragment;\n\n      // Don't include a trailing slash on the root.\n      if (fragment === '' && url !== '/') url = url.slice(0, -1);\n\n      // If pushState is available, we use it to set the fragment as a real URL.\n      if (this._hasPushState) {\n        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);\n\n      // If hash changes haven't been explicitly disabled, update the hash\n      // fragment to store history.\n      } else if (this._wantsHashChange) {\n        this._updateHash(this.location, fragment, options.replace);\n        if (this.iframe && (fragment !== this.getFragment(this.getHash(this.iframe)))) {\n          // Opening and closing the iframe tricks IE7 and earlier to push a\n          // history entry on hash-tag change.  When replace is true, we don't\n          // want this.\n          if(!options.replace) this.iframe.document.open().close();\n          this._updateHash(this.iframe.location, fragment, options.replace);\n        }\n\n      // If you've told us that you explicitly don't want fallback hashchange-\n      // based history, then `navigate` becomes a page refresh.\n      } else {\n        return this.location.assign(url);\n      }\n      if (options.trigger) return this.loadUrl(fragment);\n    },\n\n    // Update the hash location, either replacing the current entry, or adding\n    // a new one to the browser history.\n    _updateHash: function(location, fragment, replace) {\n      if (replace) {\n        var href = location.href.replace(/(javascript:|#).*$/, '');\n        location.replace(href + '#' + fragment);\n      } else {\n        // Some browsers require that `hash` contains a leading #.\n        location.hash = '#' + fragment;\n      }\n    }\n\n  });\n\n  // Create the default Backbone.history.\n  Backbone.history = new History;\n\n  // Helpers\n  // -------\n\n  // Helper function to correctly set up the prototype chain, for subclasses.\n  // Similar to `goog.inherits`, but uses a hash of prototype properties and\n  // class properties to be extended.\n  var extend = function(protoProps, staticProps) {\n    var parent = this;\n    var child;\n\n    // The constructor function for the new subclass is either defined by you\n    // (the \"constructor\" property in your `extend` definition), or defaulted\n    // by us to simply call the parent's constructor.\n    if (protoProps && _.has(protoProps, 'constructor')) {\n      child = protoProps.constructor;\n    } else {\n      child = function(){ return parent.apply(this, arguments); };\n    }\n\n    // Add static properties to the constructor function, if supplied.\n    _.extend(child, parent, staticProps);\n\n    // Set the prototype chain to inherit from `parent`, without calling\n    // `parent`'s constructor function.\n    var Surrogate = function(){ this.constructor = child; };\n    Surrogate.prototype = parent.prototype;\n    child.prototype = new Surrogate;\n\n    // Add prototype properties (instance properties) to the subclass,\n    // if supplied.\n    if (protoProps) _.extend(child.prototype, protoProps);\n\n    // Set a convenience property in case the parent's prototype is needed\n    // later.\n    child.__super__ = parent.prototype;\n\n    return child;\n  };\n\n  // Set up inheritance for the model, collection, router, view and history.\n  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;\n\n  // Throw an error when a URL is needed, and none is supplied.\n  var urlError = function() {\n    throw new Error('A \"url\" property or function must be specified');\n  };\n\n  // Wrap an optional error callback with a fallback error event.\n  var wrapError = function(model, options) {\n    var error = options.error;\n    options.error = function(resp) {\n      if (error) error(model, resp, options);\n      model.trigger('error', model, resp, options);\n    };\n  };\n\n  return Backbone;\n\n}));\n\n\n//# sourceURL=webpack:///./.plone/++plone++static/components/backbone/backbone.js?");

/***/ }),

/***/ "./.plone/++plone++static/components/bootstrap/js/dropdown.js":
/*!********************************************************************!*\
  !*** ./.plone/++plone++static/components/bootstrap/js/dropdown.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*** IMPORTS FROM imports-loader ***/\nvar jQuery = __webpack_require__(/*! jquery */ \"./.plone/++plone++static/components/jquery/dist/jquery.min.js\");\n\n/* ========================================================================\n * Bootstrap: dropdown.js v3.4.1\n * https://getbootstrap.com/docs/3.4/javascript/#dropdowns\n * ========================================================================\n * Copyright 2011-2019 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // DROPDOWN CLASS DEFINITION\n  // =========================\n\n  var backdrop = '.dropdown-backdrop'\n  var toggle   = '[data-toggle=\"dropdown\"]'\n  var Dropdown = function (element) {\n    $(element).on('click.bs.dropdown', this.toggle)\n  }\n\n  Dropdown.VERSION = '3.4.1'\n\n  function getParent($this) {\n    var selector = $this.attr('data-target')\n\n    if (!selector) {\n      selector = $this.attr('href')\n      selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\\s]*$)/, '') // strip for ie7\n    }\n\n    var $parent = selector !== '#' ? $(document).find(selector) : null\n\n    return $parent && $parent.length ? $parent : $this.parent()\n  }\n\n  function clearMenus(e) {\n    if (e && e.which === 3) return\n    $(backdrop).remove()\n    $(toggle).each(function () {\n      var $this         = $(this)\n      var $parent       = getParent($this)\n      var relatedTarget = { relatedTarget: this }\n\n      if (!$parent.hasClass('open')) return\n\n      if (e && e.type == 'click' && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target)) return\n\n      $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget))\n\n      if (e.isDefaultPrevented()) return\n\n      $this.attr('aria-expanded', 'false')\n      $parent.removeClass('open').trigger($.Event('hidden.bs.dropdown', relatedTarget))\n    })\n  }\n\n  Dropdown.prototype.toggle = function (e) {\n    var $this = $(this)\n\n    if ($this.is('.disabled, :disabled')) return\n\n    var $parent  = getParent($this)\n    var isActive = $parent.hasClass('open')\n\n    clearMenus()\n\n    if (!isActive) {\n      if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {\n        // if mobile we use a backdrop because click events don't delegate\n        $(document.createElement('div'))\n          .addClass('dropdown-backdrop')\n          .insertAfter($(this))\n          .on('click', clearMenus)\n      }\n\n      var relatedTarget = { relatedTarget: this }\n      $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget))\n\n      if (e.isDefaultPrevented()) return\n\n      $this\n        .trigger('focus')\n        .attr('aria-expanded', 'true')\n\n      $parent\n        .toggleClass('open')\n        .trigger($.Event('shown.bs.dropdown', relatedTarget))\n    }\n\n    return false\n  }\n\n  Dropdown.prototype.keydown = function (e) {\n    if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return\n\n    var $this = $(this)\n\n    e.preventDefault()\n    e.stopPropagation()\n\n    if ($this.is('.disabled, :disabled')) return\n\n    var $parent  = getParent($this)\n    var isActive = $parent.hasClass('open')\n\n    if (!isActive && e.which != 27 || isActive && e.which == 27) {\n      if (e.which == 27) $parent.find(toggle).trigger('focus')\n      return $this.trigger('click')\n    }\n\n    var desc = ' li:not(.disabled):visible a'\n    var $items = $parent.find('.dropdown-menu' + desc)\n\n    if (!$items.length) return\n\n    var index = $items.index(e.target)\n\n    if (e.which == 38 && index > 0)                 index--         // up\n    if (e.which == 40 && index < $items.length - 1) index++         // down\n    if (!~index)                                    index = 0\n\n    $items.eq(index).trigger('focus')\n  }\n\n\n  // DROPDOWN PLUGIN DEFINITION\n  // ==========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this = $(this)\n      var data  = $this.data('bs.dropdown')\n\n      if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)))\n      if (typeof option == 'string') data[option].call($this)\n    })\n  }\n\n  var old = $.fn.dropdown\n\n  $.fn.dropdown             = Plugin\n  $.fn.dropdown.Constructor = Dropdown\n\n\n  // DROPDOWN NO CONFLICT\n  // ====================\n\n  $.fn.dropdown.noConflict = function () {\n    $.fn.dropdown = old\n    return this\n  }\n\n\n  // APPLY TO STANDARD DROPDOWN ELEMENTS\n  // ===================================\n\n  $(document)\n    .on('click.bs.dropdown.data-api', clearMenus)\n    .on('click.bs.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() })\n    .on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle)\n    .on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown)\n    .on('keydown.bs.dropdown.data-api', '.dropdown-menu', Dropdown.prototype.keydown)\n\n}(jQuery);\n\n\n\n//# sourceURL=webpack:///./.plone/++plone++static/components/bootstrap/js/dropdown.js?");

/***/ }),

/***/ "./.plone/++plone++static/components/jquery-form/src/jquery.form.js":
/*!**************************************************************************!*\
  !*** ./.plone/++plone++static/components/jquery-form/src/jquery.form.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * jQuery Form Plugin\n * version: 4.2.2\n * Requires jQuery v1.7.2 or later\n * Project repository: https://github.com/jquery-form/form\n\n * Copyright 2017 Kevin Morris\n * Copyright 2006 M. Alsup\n\n * Dual licensed under the LGPL-2.1+ or MIT licenses\n * https://github.com/jquery-form/form#license\n\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n */\n/* global ActiveXObject */\n\n/* eslint-disable */\n(function (factory) {\n\tif (true) {\n\t\t// AMD. Register as an anonymous module.\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"./.plone/++plone++static/components/jquery/dist/jquery.min.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n\n}(function ($) {\n/* eslint-enable */\n\t'use strict';\n\n\t/*\n\t\tUsage Note:\n\t\t-----------\n\t\tDo not use both ajaxSubmit and ajaxForm on the same form. These\n\t\tfunctions are mutually exclusive. Use ajaxSubmit if you want\n\t\tto bind your own submit handler to the form. For example,\n\n\t\t$(document).ready(function() {\n\t\t\t$('#myForm').on('submit', function(e) {\n\t\t\t\te.preventDefault(); // <-- important\n\t\t\t\t$(this).ajaxSubmit({\n\t\t\t\t\ttarget: '#output'\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tUse ajaxForm when you want the plugin to manage all the event binding\n\t\tfor you. For example,\n\n\t\t$(document).ready(function() {\n\t\t\t$('#myForm').ajaxForm({\n\t\t\t\ttarget: '#output'\n\t\t\t});\n\t\t});\n\n\t\tYou can also use ajaxForm with delegation (requires jQuery v1.7+), so the\n\t\tform does not have to exist when you invoke ajaxForm:\n\n\t\t$('#myForm').ajaxForm({\n\t\t\tdelegation: true,\n\t\t\ttarget: '#output'\n\t\t});\n\n\t\tWhen using ajaxForm, the ajaxSubmit function will be invoked for you\n\t\tat the appropriate time.\n\t*/\n\n\tvar rCRLF = /\\r?\\n/g;\n\n\t/**\n\t * Feature detection\n\t */\n\tvar feature = {};\n\n\tfeature.fileapi = $('<input type=\"file\">').get(0).files !== undefined;\n\tfeature.formdata = (typeof window.FormData !== 'undefined');\n\n\tvar hasProp = !!$.fn.prop;\n\n\t// attr2 uses prop when it can but checks the return type for\n\t// an expected string. This accounts for the case where a form\n\t// contains inputs with names like \"action\" or \"method\"; in those\n\t// cases \"prop\" returns the element\n\t$.fn.attr2 = function() {\n\t\tif (!hasProp) {\n\t\t\treturn this.attr.apply(this, arguments);\n\t\t}\n\n\t\tvar val = this.prop.apply(this, arguments);\n\n\t\tif ((val && val.jquery) || typeof val === 'string') {\n\t\t\treturn val;\n\t\t}\n\n\t\treturn this.attr.apply(this, arguments);\n\t};\n\n\t/**\n\t * ajaxSubmit() provides a mechanism for immediately submitting\n\t * an HTML form using AJAX.\n\t *\n\t * @param\t{object|string}\toptions\t\tjquery.form.js parameters or custom url for submission\n\t * @param\t{object}\t\tdata\t\textraData\n\t * @param\t{string}\t\tdataType\tajax dataType\n\t * @param\t{function}\t\tonSuccess\tajax success callback function\n\t */\n\t$.fn.ajaxSubmit = function(options, data, dataType, onSuccess) {\n\t\t// fast fail if nothing selected (http://dev.jquery.com/ticket/2752)\n\t\tif (!this.length) {\n\t\t\tlog('ajaxSubmit: skipping submit process - no element selected');\n\n\t\t\treturn this;\n\t\t}\n\n\t\t/* eslint consistent-this: [\"error\", \"$form\"] */\n\t\tvar method, action, url, $form = this;\n\n\t\tif (typeof options === 'function') {\n\t\t\toptions = {success: options};\n\n\t\t} else if (typeof options === 'string' || (options === false && arguments.length > 0)) {\n\t\t\toptions = {\n\t\t\t\t'url'      : options,\n\t\t\t\t'data'     : data,\n\t\t\t\t'dataType' : dataType\n\t\t\t};\n\n\t\t\tif (typeof onSuccess === 'function') {\n\t\t\t\toptions.success = onSuccess;\n\t\t\t}\n\n\t\t} else if (typeof options === 'undefined') {\n\t\t\toptions = {};\n\t\t}\n\n\t\tmethod = options.method || options.type || this.attr2('method');\n\t\taction = options.url || this.attr2('action');\n\n\t\turl = (typeof action === 'string') ? $.trim(action) : '';\n\t\turl = url || window.location.href || '';\n\t\tif (url) {\n\t\t\t// clean url (don't include hash vaue)\n\t\t\turl = (url.match(/^([^#]+)/) || [])[1];\n\t\t}\n\n\t\toptions = $.extend(true, {\n\t\t\turl       : url,\n\t\t\tsuccess   : $.ajaxSettings.success,\n\t\t\ttype      : method || $.ajaxSettings.type,\n\t\t\tiframeSrc : /^https/i.test(window.location.href || '') ? 'javascript:false' : 'about:blank'\t\t// eslint-disable-line no-script-url\n\t\t}, options);\n\n\t\t// hook for manipulating the form data before it is extracted;\n\t\t// convenient for use with rich editors like tinyMCE or FCKEditor\n\t\tvar veto = {};\n\n\t\tthis.trigger('form-pre-serialize', [this, options, veto]);\n\n\t\tif (veto.veto) {\n\t\t\tlog('ajaxSubmit: submit vetoed via form-pre-serialize trigger');\n\n\t\t\treturn this;\n\t\t}\n\n\t\t// provide opportunity to alter form data before it is serialized\n\t\tif (options.beforeSerialize && options.beforeSerialize(this, options) === false) {\n\t\t\tlog('ajaxSubmit: submit aborted via beforeSerialize callback');\n\n\t\t\treturn this;\n\t\t}\n\n\t\tvar traditional = options.traditional;\n\n\t\tif (typeof traditional === 'undefined') {\n\t\t\ttraditional = $.ajaxSettings.traditional;\n\t\t}\n\n\t\tvar elements = [];\n\t\tvar qx, a = this.formToArray(options.semantic, elements, options.filtering);\n\n\t\tif (options.data) {\n\t\t\tvar optionsData = $.isFunction(options.data) ? options.data(a) : options.data;\n\n\t\t\toptions.extraData = optionsData;\n\t\t\tqx = $.param(optionsData, traditional);\n\t\t}\n\n\t\t// give pre-submit callback an opportunity to abort the submit\n\t\tif (options.beforeSubmit && options.beforeSubmit(a, this, options) === false) {\n\t\t\tlog('ajaxSubmit: submit aborted via beforeSubmit callback');\n\n\t\t\treturn this;\n\t\t}\n\n\t\t// fire vetoable 'validate' event\n\t\tthis.trigger('form-submit-validate', [a, this, options, veto]);\n\t\tif (veto.veto) {\n\t\t\tlog('ajaxSubmit: submit vetoed via form-submit-validate trigger');\n\n\t\t\treturn this;\n\t\t}\n\n\t\tvar q = $.param(a, traditional);\n\n\t\tif (qx) {\n\t\t\tq = (q ? (q + '&' + qx) : qx);\n\t\t}\n\n\t\tif (options.type.toUpperCase() === 'GET') {\n\t\t\toptions.url += (options.url.indexOf('?') >= 0 ? '&' : '?') + q;\n\t\t\toptions.data = null;\t// data is null for 'get'\n\t\t} else {\n\t\t\toptions.data = q;\t\t// data is the query string for 'post'\n\t\t}\n\n\t\tvar callbacks = [];\n\n\t\tif (options.resetForm) {\n\t\t\tcallbacks.push(function() {\n\t\t\t\t$form.resetForm();\n\t\t\t});\n\t\t}\n\n\t\tif (options.clearForm) {\n\t\t\tcallbacks.push(function() {\n\t\t\t\t$form.clearForm(options.includeHidden);\n\t\t\t});\n\t\t}\n\n\t\t// perform a load on the target only if dataType is not provided\n\t\tif (!options.dataType && options.target) {\n\t\t\tvar oldSuccess = options.success || function(){};\n\n\t\t\tcallbacks.push(function(data, textStatus, jqXHR) {\n\t\t\t\tvar successArguments = arguments,\n\t\t\t\t\tfn = options.replaceTarget ? 'replaceWith' : 'html';\n\n\t\t\t\t$(options.target)[fn](data).each(function(){\n\t\t\t\t\toldSuccess.apply(this, successArguments);\n\t\t\t\t});\n\t\t\t});\n\n\t\t} else if (options.success) {\n\t\t\tif ($.isArray(options.success)) {\n\t\t\t\t$.merge(callbacks, options.success);\n\t\t\t} else {\n\t\t\t\tcallbacks.push(options.success);\n\t\t\t}\n\t\t}\n\n\t\toptions.success = function(data, status, xhr) { // jQuery 1.4+ passes xhr as 3rd arg\n\t\t\tvar context = options.context || this;\t\t// jQuery 1.4+ supports scope context\n\n\t\t\tfor (var i = 0, max = callbacks.length; i < max; i++) {\n\t\t\t\tcallbacks[i].apply(context, [data, status, xhr || $form, $form]);\n\t\t\t}\n\t\t};\n\n\t\tif (options.error) {\n\t\t\tvar oldError = options.error;\n\n\t\t\toptions.error = function(xhr, status, error) {\n\t\t\t\tvar context = options.context || this;\n\n\t\t\t\toldError.apply(context, [xhr, status, error, $form]);\n\t\t\t};\n\t\t}\n\n\t\tif (options.complete) {\n\t\t\tvar oldComplete = options.complete;\n\n\t\t\toptions.complete = function(xhr, status) {\n\t\t\t\tvar context = options.context || this;\n\n\t\t\t\toldComplete.apply(context, [xhr, status, $form]);\n\t\t\t};\n\t\t}\n\n\t\t// are there files to upload?\n\n\t\t// [value] (issue #113), also see comment:\n\t\t// https://github.com/malsup/form/commit/588306aedba1de01388032d5f42a60159eea9228#commitcomment-2180219\n\t\tvar fileInputs = $('input[type=file]:enabled', this).filter(function() {\n\t\t\treturn $(this).val() !== '';\n\t\t});\n\t\tvar hasFileInputs = fileInputs.length > 0;\n\t\tvar mp = 'multipart/form-data';\n\t\tvar multipart = ($form.attr('enctype') === mp || $form.attr('encoding') === mp);\n\t\tvar fileAPI = feature.fileapi && feature.formdata;\n\n\t\tlog('fileAPI :' + fileAPI);\n\n\t\tvar shouldUseFrame = (hasFileInputs || multipart) && !fileAPI;\n\t\tvar jqxhr;\n\n\t\t// options.iframe allows user to force iframe mode\n\t\t// 06-NOV-09: now defaulting to iframe mode if file input is detected\n\t\tif (options.iframe !== false && (options.iframe || shouldUseFrame)) {\n\t\t\t// hack to fix Safari hang (thanks to Tim Molendijk for this)\n\t\t\t// see: http://groups.google.com/group/jquery-dev/browse_thread/thread/36395b7ab510dd5d\n\t\t\tif (options.closeKeepAlive) {\n\t\t\t\t$.get(options.closeKeepAlive, function() {\n\t\t\t\t\tjqxhr = fileUploadIframe(a);\n\t\t\t\t});\n\n\t\t\t} else {\n\t\t\t\tjqxhr = fileUploadIframe(a);\n\t\t\t}\n\n\t\t} else if ((hasFileInputs || multipart) && fileAPI) {\n\t\t\tjqxhr = fileUploadXhr(a);\n\n\t\t} else {\n\t\t\tjqxhr = $.ajax(options);\n\t\t}\n\n\t\t$form.removeData('jqxhr').data('jqxhr', jqxhr);\n\n\t\t// clear element array\n\t\tfor (var k = 0; k < elements.length; k++) {\n\t\t\telements[k] = null;\n\t\t}\n\n\t\t// fire 'notify' event\n\t\tthis.trigger('form-submit-notify', [this, options]);\n\n\t\treturn this;\n\n\t\t// utility fn for deep serialization\n\t\tfunction deepSerialize(extraData) {\n\t\t\tvar serialized = $.param(extraData, options.traditional).split('&');\n\t\t\tvar len = serialized.length;\n\t\t\tvar result = [];\n\t\t\tvar i, part;\n\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t// #252; undo param space replacement\n\t\t\t\tserialized[i] = serialized[i].replace(/\\+/g, ' ');\n\t\t\t\tpart = serialized[i].split('=');\n\t\t\t\t// #278; use array instead of object storage, favoring array serializations\n\t\t\t\tresult.push([decodeURIComponent(part[0]), decodeURIComponent(part[1])]);\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\n\t\t// XMLHttpRequest Level 2 file uploads (big hat tip to francois2metz)\n\t\tfunction fileUploadXhr(a) {\n\t\t\tvar formdata = new FormData();\n\n\t\t\tfor (var i = 0; i < a.length; i++) {\n\t\t\t\tformdata.append(a[i].name, a[i].value);\n\t\t\t}\n\n\t\t\tif (options.extraData) {\n\t\t\t\tvar serializedData = deepSerialize(options.extraData);\n\n\t\t\t\tfor (i = 0; i < serializedData.length; i++) {\n\t\t\t\t\tif (serializedData[i]) {\n\t\t\t\t\t\tformdata.append(serializedData[i][0], serializedData[i][1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toptions.data = null;\n\n\t\t\tvar s = $.extend(true, {}, $.ajaxSettings, options, {\n\t\t\t\tcontentType : false,\n\t\t\t\tprocessData : false,\n\t\t\t\tcache       : false,\n\t\t\t\ttype        : method || 'POST'\n\t\t\t});\n\n\t\t\tif (options.uploadProgress) {\n\t\t\t\t// workaround because jqXHR does not expose upload property\n\t\t\t\ts.xhr = function() {\n\t\t\t\t\tvar xhr = $.ajaxSettings.xhr();\n\n\t\t\t\t\tif (xhr.upload) {\n\t\t\t\t\t\txhr.upload.addEventListener('progress', function(event) {\n\t\t\t\t\t\t\tvar percent = 0;\n\t\t\t\t\t\t\tvar position = event.loaded || event.position;\t\t\t/* event.position is deprecated */\n\t\t\t\t\t\t\tvar total = event.total;\n\n\t\t\t\t\t\t\tif (event.lengthComputable) {\n\t\t\t\t\t\t\t\tpercent = Math.ceil(position / total * 100);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\toptions.uploadProgress(event, position, total, percent);\n\t\t\t\t\t\t}, false);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn xhr;\n\t\t\t\t};\n\t\t\t}\n\n\t\t\ts.data = null;\n\n\t\t\tvar beforeSend = s.beforeSend;\n\n\t\t\ts.beforeSend = function(xhr, o) {\n\t\t\t\t// Send FormData() provided by user\n\t\t\t\tif (options.formData) {\n\t\t\t\t\to.data = options.formData;\n\t\t\t\t} else {\n\t\t\t\t\to.data = formdata;\n\t\t\t\t}\n\n\t\t\t\tif (beforeSend) {\n\t\t\t\t\tbeforeSend.call(this, xhr, o);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\treturn $.ajax(s);\n\t\t}\n\n\t\t// private function for handling file uploads (hat tip to YAHOO!)\n\t\tfunction fileUploadIframe(a) {\n\t\t\tvar form = $form[0], el, i, s, g, id, $io, io, xhr, sub, n, timedOut, timeoutHandle;\n\t\t\tvar deferred = $.Deferred();\n\n\t\t\t// #341\n\t\t\tdeferred.abort = function(status) {\n\t\t\t\txhr.abort(status);\n\t\t\t};\n\n\t\t\tif (a) {\n\t\t\t\t// ensure that every serialized input is still enabled\n\t\t\t\tfor (i = 0; i < elements.length; i++) {\n\t\t\t\t\tel = $(elements[i]);\n\t\t\t\t\tif (hasProp) {\n\t\t\t\t\t\tel.prop('disabled', false);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tel.removeAttr('disabled');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ts = $.extend(true, {}, $.ajaxSettings, options);\n\t\t\ts.context = s.context || s;\n\t\t\tid = 'jqFormIO' + new Date().getTime();\n\t\t\tvar ownerDocument = form.ownerDocument;\n\t\t\tvar $body = $form.closest('body');\n\n\t\t\tif (s.iframeTarget) {\n\t\t\t\t$io = $(s.iframeTarget, ownerDocument);\n\t\t\t\tn = $io.attr2('name');\n\t\t\t\tif (!n) {\n\t\t\t\t\t$io.attr2('name', id);\n\t\t\t\t} else {\n\t\t\t\t\tid = n;\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t$io = $('<iframe name=\"' + id + '\" src=\"' + s.iframeSrc + '\" />', ownerDocument);\n\t\t\t\t$io.css({position: 'absolute', top: '-1000px', left: '-1000px'});\n\t\t\t}\n\t\t\tio = $io[0];\n\n\n\t\t\txhr = { // mock object\n\t\t\t\taborted               : 0,\n\t\t\t\tresponseText          : null,\n\t\t\t\tresponseXML           : null,\n\t\t\t\tstatus                : 0,\n\t\t\t\tstatusText            : 'n/a',\n\t\t\t\tgetAllResponseHeaders : function() {},\n\t\t\t\tgetResponseHeader     : function() {},\n\t\t\t\tsetRequestHeader      : function() {},\n\t\t\t\tabort                 : function(status) {\n\t\t\t\t\tvar e = (status === 'timeout' ? 'timeout' : 'aborted');\n\n\t\t\t\t\tlog('aborting upload... ' + e);\n\t\t\t\t\tthis.aborted = 1;\n\n\t\t\t\t\ttry { // #214, #257\n\t\t\t\t\t\tif (io.contentWindow.document.execCommand) {\n\t\t\t\t\t\t\tio.contentWindow.document.execCommand('Stop');\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (ignore) {}\n\n\t\t\t\t\t$io.attr('src', s.iframeSrc); // abort op in progress\n\t\t\t\t\txhr.error = e;\n\t\t\t\t\tif (s.error) {\n\t\t\t\t\t\ts.error.call(s.context, xhr, e, status);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (g) {\n\t\t\t\t\t\t$.event.trigger('ajaxError', [xhr, s, e]);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (s.complete) {\n\t\t\t\t\t\ts.complete.call(s.context, xhr, e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tg = s.global;\n\t\t\t// trigger ajax global events so that activity/block indicators work like normal\n\t\t\tif (g && $.active++ === 0) {\n\t\t\t\t$.event.trigger('ajaxStart');\n\t\t\t}\n\t\t\tif (g) {\n\t\t\t\t$.event.trigger('ajaxSend', [xhr, s]);\n\t\t\t}\n\n\t\t\tif (s.beforeSend && s.beforeSend.call(s.context, xhr, s) === false) {\n\t\t\t\tif (s.global) {\n\t\t\t\t\t$.active--;\n\t\t\t\t}\n\t\t\t\tdeferred.reject();\n\n\t\t\t\treturn deferred;\n\t\t\t}\n\n\t\t\tif (xhr.aborted) {\n\t\t\t\tdeferred.reject();\n\n\t\t\t\treturn deferred;\n\t\t\t}\n\n\t\t\t// add submitting element to data if we know it\n\t\t\tsub = form.clk;\n\t\t\tif (sub) {\n\t\t\t\tn = sub.name;\n\t\t\t\tif (n && !sub.disabled) {\n\t\t\t\t\ts.extraData = s.extraData || {};\n\t\t\t\t\ts.extraData[n] = sub.value;\n\t\t\t\t\tif (sub.type === 'image') {\n\t\t\t\t\t\ts.extraData[n + '.x'] = form.clk_x;\n\t\t\t\t\t\ts.extraData[n + '.y'] = form.clk_y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar CLIENT_TIMEOUT_ABORT = 1;\n\t\t\tvar SERVER_ABORT = 2;\n\n\t\t\tfunction getDoc(frame) {\n\t\t\t\t/* it looks like contentWindow or contentDocument do not\n\t\t\t\t * carry the protocol property in ie8, when running under ssl\n\t\t\t\t * frame.document is the only valid response document, since\n\t\t\t\t * the protocol is know but not on the other two objects. strange?\n\t\t\t\t * \"Same origin policy\" http://en.wikipedia.org/wiki/Same_origin_policy\n\t\t\t\t */\n\n\t\t\t\tvar doc = null;\n\n\t\t\t\t// IE8 cascading access check\n\t\t\t\ttry {\n\t\t\t\t\tif (frame.contentWindow) {\n\t\t\t\t\t\tdoc = frame.contentWindow.document;\n\t\t\t\t\t}\n\t\t\t\t} catch (err) {\n\t\t\t\t\t// IE8 access denied under ssl & missing protocol\n\t\t\t\t\tlog('cannot get iframe.contentWindow document: ' + err);\n\t\t\t\t}\n\n\t\t\t\tif (doc) { // successful getting content\n\t\t\t\t\treturn doc;\n\t\t\t\t}\n\n\t\t\t\ttry { // simply checking may throw in ie8 under ssl or mismatched protocol\n\t\t\t\t\tdoc = frame.contentDocument ? frame.contentDocument : frame.document;\n\t\t\t\t} catch (err) {\n\t\t\t\t\t// last attempt\n\t\t\t\t\tlog('cannot get iframe.contentDocument: ' + err);\n\t\t\t\t\tdoc = frame.document;\n\t\t\t\t}\n\n\t\t\t\treturn doc;\n\t\t\t}\n\n\t\t\t// Rails CSRF hack (thanks to Yvan Barthelemy)\n\t\t\tvar csrf_token = $('meta[name=csrf-token]').attr('content');\n\t\t\tvar csrf_param = $('meta[name=csrf-param]').attr('content');\n\n\t\t\tif (csrf_param && csrf_token) {\n\t\t\t\ts.extraData = s.extraData || {};\n\t\t\t\ts.extraData[csrf_param] = csrf_token;\n\t\t\t}\n\n\t\t\t// take a breath so that pending repaints get some cpu time before the upload starts\n\t\t\tfunction doSubmit() {\n\t\t\t\t// make sure form attrs are set\n\t\t\t\tvar t = $form.attr2('target'),\n\t\t\t\t\ta = $form.attr2('action'),\n\t\t\t\t\tmp = 'multipart/form-data',\n\t\t\t\t\tet = $form.attr('enctype') || $form.attr('encoding') || mp;\n\n\t\t\t\t// update form attrs in IE friendly way\n\t\t\t\tform.setAttribute('target', id);\n\t\t\t\tif (!method || /post/i.test(method)) {\n\t\t\t\t\tform.setAttribute('method', 'POST');\n\t\t\t\t}\n\t\t\t\tif (a !== s.url) {\n\t\t\t\t\tform.setAttribute('action', s.url);\n\t\t\t\t}\n\n\t\t\t\t// ie borks in some cases when setting encoding\n\t\t\t\tif (!s.skipEncodingOverride && (!method || /post/i.test(method))) {\n\t\t\t\t\t$form.attr({\n\t\t\t\t\t\tencoding : 'multipart/form-data',\n\t\t\t\t\t\tenctype  : 'multipart/form-data'\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// support timout\n\t\t\t\tif (s.timeout) {\n\t\t\t\t\ttimeoutHandle = setTimeout(function() {\n\t\t\t\t\t\ttimedOut = true; cb(CLIENT_TIMEOUT_ABORT);\n\t\t\t\t\t}, s.timeout);\n\t\t\t\t}\n\n\t\t\t\t// look for server aborts\n\t\t\t\tfunction checkState() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar state = getDoc(io).readyState;\n\n\t\t\t\t\t\tlog('state = ' + state);\n\t\t\t\t\t\tif (state && state.toLowerCase() === 'uninitialized') {\n\t\t\t\t\t\t\tsetTimeout(checkState, 50);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tlog('Server abort: ', e, ' (', e.name, ')');\n\t\t\t\t\t\tcb(SERVER_ABORT);\t\t\t\t// eslint-disable-line callback-return\n\t\t\t\t\t\tif (timeoutHandle) {\n\t\t\t\t\t\t\tclearTimeout(timeoutHandle);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttimeoutHandle = undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// add \"extra\" data to form if provided in options\n\t\t\t\tvar extraInputs = [];\n\n\t\t\t\ttry {\n\t\t\t\t\tif (s.extraData) {\n\t\t\t\t\t\tfor (var n in s.extraData) {\n\t\t\t\t\t\t\tif (s.extraData.hasOwnProperty(n)) {\n\t\t\t\t\t\t\t\t// if using the $.param format that allows for multiple values with the same name\n\t\t\t\t\t\t\t\tif ($.isPlainObject(s.extraData[n]) && s.extraData[n].hasOwnProperty('name') && s.extraData[n].hasOwnProperty('value')) {\n\t\t\t\t\t\t\t\t\textraInputs.push(\n\t\t\t\t\t\t\t\t\t$('<input type=\"hidden\" name=\"' + s.extraData[n].name + '\">', ownerDocument).val(s.extraData[n].value)\n\t\t\t\t\t\t\t\t\t\t.appendTo(form)[0]);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\textraInputs.push(\n\t\t\t\t\t\t\t\t\t$('<input type=\"hidden\" name=\"' + n + '\">', ownerDocument).val(s.extraData[n])\n\t\t\t\t\t\t\t\t\t\t.appendTo(form)[0]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!s.iframeTarget) {\n\t\t\t\t\t\t// add iframe to doc and submit the form\n\t\t\t\t\t\t$io.appendTo($body);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (io.attachEvent) {\n\t\t\t\t\t\tio.attachEvent('onload', cb);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tio.addEventListener('load', cb, false);\n\t\t\t\t\t}\n\n\t\t\t\t\tsetTimeout(checkState, 15);\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tform.submit();\n\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t// just in case form has element with name/id of 'submit'\n\t\t\t\t\t\tvar submitFn = document.createElement('form').submit;\n\n\t\t\t\t\t\tsubmitFn.apply(form);\n\t\t\t\t\t}\n\n\t\t\t\t} finally {\n\t\t\t\t\t// reset attrs and remove \"extra\" input elements\n\t\t\t\t\tform.setAttribute('action', a);\n\t\t\t\t\tform.setAttribute('enctype', et); // #380\n\t\t\t\t\tif (t) {\n\t\t\t\t\t\tform.setAttribute('target', t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$form.removeAttr('target');\n\t\t\t\t\t}\n\t\t\t\t\t$(extraInputs).remove();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (s.forceSync) {\n\t\t\t\tdoSubmit();\n\t\t\t} else {\n\t\t\t\tsetTimeout(doSubmit, 10); // this lets dom updates render\n\t\t\t}\n\n\t\t\tvar data, doc, domCheckCount = 50, callbackProcessed;\n\n\t\t\tfunction cb(e) {\n\t\t\t\tif (xhr.aborted || callbackProcessed) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tdoc = getDoc(io);\n\t\t\t\tif (!doc) {\n\t\t\t\t\tlog('cannot access response document');\n\t\t\t\t\te = SERVER_ABORT;\n\t\t\t\t}\n\t\t\t\tif (e === CLIENT_TIMEOUT_ABORT && xhr) {\n\t\t\t\t\txhr.abort('timeout');\n\t\t\t\t\tdeferred.reject(xhr, 'timeout');\n\n\t\t\t\t\treturn;\n\n\t\t\t\t} else if (e === SERVER_ABORT && xhr) {\n\t\t\t\t\txhr.abort('server abort');\n\t\t\t\t\tdeferred.reject(xhr, 'error', 'server abort');\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (!doc || doc.location.href === s.iframeSrc) {\n\t\t\t\t\t// response not received yet\n\t\t\t\t\tif (!timedOut) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (io.detachEvent) {\n\t\t\t\t\tio.detachEvent('onload', cb);\n\t\t\t\t} else {\n\t\t\t\t\tio.removeEventListener('load', cb, false);\n\t\t\t\t}\n\n\t\t\t\tvar status = 'success', errMsg;\n\n\t\t\t\ttry {\n\t\t\t\t\tif (timedOut) {\n\t\t\t\t\t\tthrow 'timeout';\n\t\t\t\t\t}\n\n\t\t\t\t\tvar isXml = s.dataType === 'xml' || doc.XMLDocument || $.isXMLDoc(doc);\n\n\t\t\t\t\tlog('isXml=' + isXml);\n\n\t\t\t\t\tif (!isXml && window.opera && (doc.body === null || !doc.body.innerHTML)) {\n\t\t\t\t\t\tif (--domCheckCount) {\n\t\t\t\t\t\t\t// in some browsers (Opera) the iframe DOM is not always traversable when\n\t\t\t\t\t\t\t// the onload callback fires, so we loop a bit to accommodate\n\t\t\t\t\t\t\tlog('requeing onLoad callback, DOM not available');\n\t\t\t\t\t\t\tsetTimeout(cb, 250);\n\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// let this fall through because server response could be an empty document\n\t\t\t\t\t\t// log('Could not access iframe DOM after mutiple tries.');\n\t\t\t\t\t\t// throw 'DOMException: not available';\n\t\t\t\t\t}\n\n\t\t\t\t\t// log('response detected');\n\t\t\t\t\tvar docRoot = doc.body ? doc.body : doc.documentElement;\n\n\t\t\t\t\txhr.responseText = docRoot ? docRoot.innerHTML : null;\n\t\t\t\t\txhr.responseXML = doc.XMLDocument ? doc.XMLDocument : doc;\n\t\t\t\t\tif (isXml) {\n\t\t\t\t\t\ts.dataType = 'xml';\n\t\t\t\t\t}\n\t\t\t\t\txhr.getResponseHeader = function(header){\n\t\t\t\t\t\tvar headers = {'content-type': s.dataType};\n\n\t\t\t\t\t\treturn headers[header.toLowerCase()];\n\t\t\t\t\t};\n\t\t\t\t\t// support for XHR 'status' & 'statusText' emulation :\n\t\t\t\t\tif (docRoot) {\n\t\t\t\t\t\txhr.status = Number(docRoot.getAttribute('status')) || xhr.status;\n\t\t\t\t\t\txhr.statusText = docRoot.getAttribute('statusText') || xhr.statusText;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar dt = (s.dataType || '').toLowerCase();\n\t\t\t\t\tvar scr = /(json|script|text)/.test(dt);\n\n\t\t\t\t\tif (scr || s.textarea) {\n\t\t\t\t\t\t// see if user embedded response in textarea\n\t\t\t\t\t\tvar ta = doc.getElementsByTagName('textarea')[0];\n\n\t\t\t\t\t\tif (ta) {\n\t\t\t\t\t\t\txhr.responseText = ta.value;\n\t\t\t\t\t\t\t// support for XHR 'status' & 'statusText' emulation :\n\t\t\t\t\t\t\txhr.status = Number(ta.getAttribute('status')) || xhr.status;\n\t\t\t\t\t\t\txhr.statusText = ta.getAttribute('statusText') || xhr.statusText;\n\n\t\t\t\t\t\t} else if (scr) {\n\t\t\t\t\t\t\t// account for browsers injecting pre around json response\n\t\t\t\t\t\t\tvar pre = doc.getElementsByTagName('pre')[0];\n\t\t\t\t\t\t\tvar b = doc.getElementsByTagName('body')[0];\n\n\t\t\t\t\t\t\tif (pre) {\n\t\t\t\t\t\t\t\txhr.responseText = pre.textContent ? pre.textContent : pre.innerText;\n\t\t\t\t\t\t\t} else if (b) {\n\t\t\t\t\t\t\t\txhr.responseText = b.textContent ? b.textContent : b.innerText;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if (dt === 'xml' && !xhr.responseXML && xhr.responseText) {\n\t\t\t\t\t\txhr.responseXML = toXml(xhr.responseText);\t\t\t// eslint-disable-line no-use-before-define\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdata = httpData(xhr, dt, s);\t\t\t\t\t\t// eslint-disable-line no-use-before-define\n\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tstatus = 'parsererror';\n\t\t\t\t\t\txhr.error = errMsg = (err || status);\n\t\t\t\t\t}\n\n\t\t\t\t} catch (err) {\n\t\t\t\t\tlog('error caught: ', err);\n\t\t\t\t\tstatus = 'error';\n\t\t\t\t\txhr.error = errMsg = (err || status);\n\t\t\t\t}\n\n\t\t\t\tif (xhr.aborted) {\n\t\t\t\t\tlog('upload aborted');\n\t\t\t\t\tstatus = null;\n\t\t\t\t}\n\n\t\t\t\tif (xhr.status) { // we've set xhr.status\n\t\t\t\t\tstatus = ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304) ? 'success' : 'error';\n\t\t\t\t}\n\n\t\t\t\t// ordering of these callbacks/triggers is odd, but that's how $.ajax does it\n\t\t\t\tif (status === 'success') {\n\t\t\t\t\tif (s.success) {\n\t\t\t\t\t\ts.success.call(s.context, data, 'success', xhr);\n\t\t\t\t\t}\n\n\t\t\t\t\tdeferred.resolve(xhr.responseText, 'success', xhr);\n\n\t\t\t\t\tif (g) {\n\t\t\t\t\t\t$.event.trigger('ajaxSuccess', [xhr, s]);\n\t\t\t\t\t}\n\n\t\t\t\t} else if (status) {\n\t\t\t\t\tif (typeof errMsg === 'undefined') {\n\t\t\t\t\t\terrMsg = xhr.statusText;\n\t\t\t\t\t}\n\t\t\t\t\tif (s.error) {\n\t\t\t\t\t\ts.error.call(s.context, xhr, status, errMsg);\n\t\t\t\t\t}\n\t\t\t\t\tdeferred.reject(xhr, 'error', errMsg);\n\t\t\t\t\tif (g) {\n\t\t\t\t\t\t$.event.trigger('ajaxError', [xhr, s, errMsg]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (g) {\n\t\t\t\t\t$.event.trigger('ajaxComplete', [xhr, s]);\n\t\t\t\t}\n\n\t\t\t\tif (g && !--$.active) {\n\t\t\t\t\t$.event.trigger('ajaxStop');\n\t\t\t\t}\n\n\t\t\t\tif (s.complete) {\n\t\t\t\t\ts.complete.call(s.context, xhr, status);\n\t\t\t\t}\n\n\t\t\t\tcallbackProcessed = true;\n\t\t\t\tif (s.timeout) {\n\t\t\t\t\tclearTimeout(timeoutHandle);\n\t\t\t\t}\n\n\t\t\t\t// clean up\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\tif (!s.iframeTarget) {\n\t\t\t\t\t\t$io.remove();\n\t\t\t\t\t} else { // adding else to clean up existing iframe response.\n\t\t\t\t\t\t$io.attr('src', s.iframeSrc);\n\t\t\t\t\t}\n\t\t\t\t\txhr.responseXML = null;\n\t\t\t\t}, 100);\n\t\t\t}\n\n\t\t\tvar toXml = $.parseXML || function(s, doc) { // use parseXML if available (jQuery 1.5+)\n\t\t\t\tif (window.ActiveXObject) {\n\t\t\t\t\tdoc = new ActiveXObject('Microsoft.XMLDOM');\n\t\t\t\t\tdoc.async = 'false';\n\t\t\t\t\tdoc.loadXML(s);\n\n\t\t\t\t} else {\n\t\t\t\t\tdoc = (new DOMParser()).parseFromString(s, 'text/xml');\n\t\t\t\t}\n\n\t\t\t\treturn (doc && doc.documentElement && doc.documentElement.nodeName !== 'parsererror') ? doc : null;\n\t\t\t};\n\t\t\tvar parseJSON = $.parseJSON || function(s) {\n\t\t\t\t/* jslint evil:true */\n\t\t\t\treturn window['eval']('(' + s + ')');\t\t\t// eslint-disable-line dot-notation\n\t\t\t};\n\n\t\t\tvar httpData = function(xhr, type, s) { // mostly lifted from jq1.4.4\n\n\t\t\t\tvar ct = xhr.getResponseHeader('content-type') || '',\n\t\t\t\t\txml = ((type === 'xml' || !type) && ct.indexOf('xml') >= 0),\n\t\t\t\t\tdata = xml ? xhr.responseXML : xhr.responseText;\n\n\t\t\t\tif (xml && data.documentElement.nodeName === 'parsererror') {\n\t\t\t\t\tif ($.error) {\n\t\t\t\t\t\t$.error('parsererror');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (s && s.dataFilter) {\n\t\t\t\t\tdata = s.dataFilter(data, type);\n\t\t\t\t}\n\t\t\t\tif (typeof data === 'string') {\n\t\t\t\t\tif ((type === 'json' || !type) && ct.indexOf('json') >= 0) {\n\t\t\t\t\t\tdata = parseJSON(data);\n\t\t\t\t\t} else if ((type === 'script' || !type) && ct.indexOf('javascript') >= 0) {\n\t\t\t\t\t\t$.globalEval(data);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\t\t\t};\n\n\t\t\treturn deferred;\n\t\t}\n\t};\n\n\t/**\n\t * ajaxForm() provides a mechanism for fully automating form submission.\n\t *\n\t * The advantages of using this method instead of ajaxSubmit() are:\n\t *\n\t * 1: This method will include coordinates for <input type=\"image\"> elements (if the element\n\t *\tis used to submit the form).\n\t * 2. This method will include the submit element's name/value data (for the element that was\n\t *\tused to submit the form).\n\t * 3. This method binds the submit() method to the form for you.\n\t *\n\t * The options argument for ajaxForm works exactly as it does for ajaxSubmit. ajaxForm merely\n\t * passes the options argument along after properly binding events for submit elements and\n\t * the form itself.\n\t */\n\t$.fn.ajaxForm = function(options, data, dataType, onSuccess) {\n\t\tif (typeof options === 'string' || (options === false && arguments.length > 0)) {\n\t\t\toptions = {\n\t\t\t\t'url'      : options,\n\t\t\t\t'data'     : data,\n\t\t\t\t'dataType' : dataType\n\t\t\t};\n\n\t\t\tif (typeof onSuccess === 'function') {\n\t\t\t\toptions.success = onSuccess;\n\t\t\t}\n\t\t}\n\n\t\toptions = options || {};\n\t\toptions.delegation = options.delegation && $.isFunction($.fn.on);\n\n\t\t// in jQuery 1.3+ we can fix mistakes with the ready state\n\t\tif (!options.delegation && this.length === 0) {\n\t\t\tvar o = {s: this.selector, c: this.context};\n\n\t\t\tif (!$.isReady && o.s) {\n\t\t\t\tlog('DOM not ready, queuing ajaxForm');\n\t\t\t\t$(function() {\n\t\t\t\t\t$(o.s, o.c).ajaxForm(options);\n\t\t\t\t});\n\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\t// is your DOM ready?  http://docs.jquery.com/Tutorials:Introducing_$(document).ready()\n\t\t\tlog('terminating; zero elements found by selector' + ($.isReady ? '' : ' (DOM not ready)'));\n\n\t\t\treturn this;\n\t\t}\n\n\t\tif (options.delegation) {\n\t\t\t$(document)\n\t\t\t\t.off('submit.form-plugin', this.selector, doAjaxSubmit)\n\t\t\t\t.off('click.form-plugin', this.selector, captureSubmittingElement)\n\t\t\t\t.on('submit.form-plugin', this.selector, options, doAjaxSubmit)\n\t\t\t\t.on('click.form-plugin', this.selector, options, captureSubmittingElement);\n\n\t\t\treturn this;\n\t\t}\n\n\t\treturn this.ajaxFormUnbind()\n\t\t\t.on('submit.form-plugin', options, doAjaxSubmit)\n\t\t\t.on('click.form-plugin', options, captureSubmittingElement);\n\t};\n\n\t// private event handlers\n\tfunction doAjaxSubmit(e) {\n\t\t/* jshint validthis:true */\n\t\tvar options = e.data;\n\n\t\tif (!e.isDefaultPrevented()) { // if event has been canceled, don't proceed\n\t\t\te.preventDefault();\n\t\t\t$(e.target).closest('form').ajaxSubmit(options); // #365\n\t\t}\n\t}\n\n\tfunction captureSubmittingElement(e) {\n\t\t/* jshint validthis:true */\n\t\tvar target = e.target;\n\t\tvar $el = $(target);\n\n\t\tif (!$el.is('[type=submit],[type=image]')) {\n\t\t\t// is this a child element of the submit el?  (ex: a span within a button)\n\t\t\tvar t = $el.closest('[type=submit]');\n\n\t\t\tif (t.length === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttarget = t[0];\n\t\t}\n\n\t\tvar form = target.form;\n\n\t\tform.clk = target;\n\n\t\tif (target.type === 'image') {\n\t\t\tif (typeof e.offsetX !== 'undefined') {\n\t\t\t\tform.clk_x = e.offsetX;\n\t\t\t\tform.clk_y = e.offsetY;\n\n\t\t\t} else if (typeof $.fn.offset === 'function') {\n\t\t\t\tvar offset = $el.offset();\n\n\t\t\t\tform.clk_x = e.pageX - offset.left;\n\t\t\t\tform.clk_y = e.pageY - offset.top;\n\n\t\t\t} else {\n\t\t\t\tform.clk_x = e.pageX - target.offsetLeft;\n\t\t\t\tform.clk_y = e.pageY - target.offsetTop;\n\t\t\t}\n\t\t}\n\t\t// clear form vars\n\t\tsetTimeout(function() {\n\t\t\tform.clk = form.clk_x = form.clk_y = null;\n\t\t}, 100);\n\t}\n\n\n\t// ajaxFormUnbind unbinds the event handlers that were bound by ajaxForm\n\t$.fn.ajaxFormUnbind = function() {\n\t\treturn this.off('submit.form-plugin click.form-plugin');\n\t};\n\n\t/**\n\t * formToArray() gathers form element data into an array of objects that can\n\t * be passed to any of the following ajax functions: $.get, $.post, or load.\n\t * Each object in the array has both a 'name' and 'value' property. An example of\n\t * an array for a simple login form might be:\n\t *\n\t * [ { name: 'username', value: 'jresig' }, { name: 'password', value: 'secret' } ]\n\t *\n\t * It is this array that is passed to pre-submit callback functions provided to the\n\t * ajaxSubmit() and ajaxForm() methods.\n\t */\n\t$.fn.formToArray = function(semantic, elements, filtering) {\n\t\tvar a = [];\n\n\t\tif (this.length === 0) {\n\t\t\treturn a;\n\t\t}\n\n\t\tvar form = this[0];\n\t\tvar formId = this.attr('id');\n\t\tvar els = (semantic || typeof form.elements === 'undefined') ? form.getElementsByTagName('*') : form.elements;\n\t\tvar els2;\n\n\t\tif (els) {\n\t\t\tels = $.makeArray(els); // convert to standard array\n\t\t}\n\n\t\t// #386; account for inputs outside the form which use the 'form' attribute\n\t\t// FinesseRus: in non-IE browsers outside fields are already included in form.elements.\n\t\tif (formId && (semantic || /(Edge|Trident)\\//.test(navigator.userAgent))) {\n\t\t\tels2 = $(':input[form=\"' + formId + '\"]').get(); // hat tip @thet\n\t\t\tif (els2.length) {\n\t\t\t\tels = (els || []).concat(els2);\n\t\t\t}\n\t\t}\n\n\t\tif (!els || !els.length) {\n\t\t\treturn a;\n\t\t}\n\n\t\tif ($.isFunction(filtering)) {\n\t\t\tels = $.map(els, filtering);\n\t\t}\n\n\t\tvar i, j, n, v, el, max, jmax;\n\n\t\tfor (i = 0, max = els.length; i < max; i++) {\n\t\t\tel = els[i];\n\t\t\tn = el.name;\n\t\t\tif (!n || el.disabled) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (semantic && form.clk && el.type === 'image') {\n\t\t\t\t// handle image inputs on the fly when semantic == true\n\t\t\t\tif (form.clk === el) {\n\t\t\t\t\ta.push({name: n, value: $(el).val(), type: el.type});\n\t\t\t\t\ta.push({name: n + '.x', value: form.clk_x}, {name: n + '.y', value: form.clk_y});\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tv = $.fieldValue(el, true);\n\t\t\tif (v && v.constructor === Array) {\n\t\t\t\tif (elements) {\n\t\t\t\t\telements.push(el);\n\t\t\t\t}\n\t\t\t\tfor (j = 0, jmax = v.length; j < jmax; j++) {\n\t\t\t\t\ta.push({name: n, value: v[j]});\n\t\t\t\t}\n\n\t\t\t} else if (feature.fileapi && el.type === 'file') {\n\t\t\t\tif (elements) {\n\t\t\t\t\telements.push(el);\n\t\t\t\t}\n\n\t\t\t\tvar files = el.files;\n\n\t\t\t\tif (files.length) {\n\t\t\t\t\tfor (j = 0; j < files.length; j++) {\n\t\t\t\t\t\ta.push({name: n, value: files[j], type: el.type});\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// #180\n\t\t\t\t\ta.push({name: n, value: '', type: el.type});\n\t\t\t\t}\n\n\t\t\t} else if (v !== null && typeof v !== 'undefined') {\n\t\t\t\tif (elements) {\n\t\t\t\t\telements.push(el);\n\t\t\t\t}\n\t\t\t\ta.push({name: n, value: v, type: el.type, required: el.required});\n\t\t\t}\n\t\t}\n\n\t\tif (!semantic && form.clk) {\n\t\t\t// input type=='image' are not found in elements array! handle it here\n\t\t\tvar $input = $(form.clk), input = $input[0];\n\n\t\t\tn = input.name;\n\n\t\t\tif (n && !input.disabled && input.type === 'image') {\n\t\t\t\ta.push({name: n, value: $input.val()});\n\t\t\t\ta.push({name: n + '.x', value: form.clk_x}, {name: n + '.y', value: form.clk_y});\n\t\t\t}\n\t\t}\n\n\t\treturn a;\n\t};\n\n\t/**\n\t * Serializes form data into a 'submittable' string. This method will return a string\n\t * in the format: name1=value1&amp;name2=value2\n\t */\n\t$.fn.formSerialize = function(semantic) {\n\t\t// hand off to jQuery.param for proper encoding\n\t\treturn $.param(this.formToArray(semantic));\n\t};\n\n\t/**\n\t * Serializes all field elements in the jQuery object into a query string.\n\t * This method will return a string in the format: name1=value1&amp;name2=value2\n\t */\n\t$.fn.fieldSerialize = function(successful) {\n\t\tvar a = [];\n\n\t\tthis.each(function() {\n\t\t\tvar n = this.name;\n\n\t\t\tif (!n) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar v = $.fieldValue(this, successful);\n\n\t\t\tif (v && v.constructor === Array) {\n\t\t\t\tfor (var i = 0, max = v.length; i < max; i++) {\n\t\t\t\t\ta.push({name: n, value: v[i]});\n\t\t\t\t}\n\n\t\t\t} else if (v !== null && typeof v !== 'undefined') {\n\t\t\t\ta.push({name: this.name, value: v});\n\t\t\t}\n\t\t});\n\n\t\t// hand off to jQuery.param for proper encoding\n\t\treturn $.param(a);\n\t};\n\n\t/**\n\t * Returns the value(s) of the element in the matched set. For example, consider the following form:\n\t *\n\t *\t<form><fieldset>\n\t *\t\t<input name=\"A\" type=\"text\">\n\t *\t\t<input name=\"A\" type=\"text\">\n\t *\t\t<input name=\"B\" type=\"checkbox\" value=\"B1\">\n\t *\t\t<input name=\"B\" type=\"checkbox\" value=\"B2\">\n\t *\t\t<input name=\"C\" type=\"radio\" value=\"C1\">\n\t *\t\t<input name=\"C\" type=\"radio\" value=\"C2\">\n\t *\t</fieldset></form>\n\t *\n\t *\tvar v = $('input[type=text]').fieldValue();\n\t *\t// if no values are entered into the text inputs\n\t *\tv === ['','']\n\t *\t// if values entered into the text inputs are 'foo' and 'bar'\n\t *\tv === ['foo','bar']\n\t *\n\t *\tvar v = $('input[type=checkbox]').fieldValue();\n\t *\t// if neither checkbox is checked\n\t *\tv === undefined\n\t *\t// if both checkboxes are checked\n\t *\tv === ['B1', 'B2']\n\t *\n\t *\tvar v = $('input[type=radio]').fieldValue();\n\t *\t// if neither radio is checked\n\t *\tv === undefined\n\t *\t// if first radio is checked\n\t *\tv === ['C1']\n\t *\n\t * The successful argument controls whether or not the field element must be 'successful'\n\t * (per http://www.w3.org/TR/html4/interact/forms.html#successful-controls).\n\t * The default value of the successful argument is true. If this value is false the value(s)\n\t * for each element is returned.\n\t *\n\t * Note: This method *always* returns an array. If no valid value can be determined the\n\t *\tarray will be empty, otherwise it will contain one or more values.\n\t */\n\t$.fn.fieldValue = function(successful) {\n\t\tfor (var val = [], i = 0, max = this.length; i < max; i++) {\n\t\t\tvar el = this[i];\n\t\t\tvar v = $.fieldValue(el, successful);\n\n\t\t\tif (v === null || typeof v === 'undefined' || (v.constructor === Array && !v.length)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (v.constructor === Array) {\n\t\t\t\t$.merge(val, v);\n\t\t\t} else {\n\t\t\t\tval.push(v);\n\t\t\t}\n\t\t}\n\n\t\treturn val;\n\t};\n\n\t/**\n\t * Returns the value of the field element.\n\t */\n\t$.fieldValue = function(el, successful) {\n\t\tvar n = el.name, t = el.type, tag = el.tagName.toLowerCase();\n\n\t\tif (typeof successful === 'undefined') {\n\t\t\tsuccessful = true;\n\t\t}\n\n\t\t/* eslint-disable no-mixed-operators */\n\t\tif (successful && (!n || el.disabled || t === 'reset' || t === 'button' ||\n\t\t\t(t === 'checkbox' || t === 'radio') && !el.checked ||\n\t\t\t(t === 'submit' || t === 'image') && el.form && el.form.clk !== el ||\n\t\t\ttag === 'select' && el.selectedIndex === -1)) {\n\t\t/* eslint-enable no-mixed-operators */\n\t\t\treturn null;\n\t\t}\n\n\t\tif (tag === 'select') {\n\t\t\tvar index = el.selectedIndex;\n\n\t\t\tif (index < 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvar a = [], ops = el.options;\n\t\t\tvar one = (t === 'select-one');\n\t\t\tvar max = (one ? index + 1 : ops.length);\n\n\t\t\tfor (var i = (one ? index : 0); i < max; i++) {\n\t\t\t\tvar op = ops[i];\n\n\t\t\t\tif (op.selected && !op.disabled) {\n\t\t\t\t\tvar v = op.value;\n\n\t\t\t\t\tif (!v) { // extra pain for IE...\n\t\t\t\t\t\tv = (op.attributes && op.attributes.value && !(op.attributes.value.specified)) ? op.text : op.value;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (one) {\n\t\t\t\t\t\treturn v;\n\t\t\t\t\t}\n\n\t\t\t\t\ta.push(v);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn a;\n\t\t}\n\n\t\treturn $(el).val().replace(rCRLF, '\\r\\n');\n\t};\n\n\t/**\n\t * Clears the form data. Takes the following actions on the form's input fields:\n\t *  - input text fields will have their 'value' property set to the empty string\n\t *  - select elements will have their 'selectedIndex' property set to -1\n\t *  - checkbox and radio inputs will have their 'checked' property set to false\n\t *  - inputs of type submit, button, reset, and hidden will *not* be effected\n\t *  - button elements will *not* be effected\n\t */\n\t$.fn.clearForm = function(includeHidden) {\n\t\treturn this.each(function() {\n\t\t\t$('input,select,textarea', this).clearFields(includeHidden);\n\t\t});\n\t};\n\n\t/**\n\t * Clears the selected form elements.\n\t */\n\t$.fn.clearFields = $.fn.clearInputs = function(includeHidden) {\n\t\tvar re = /^(?:color|date|datetime|email|month|number|password|range|search|tel|text|time|url|week)$/i; // 'hidden' is not in this list\n\n\t\treturn this.each(function() {\n\t\t\tvar t = this.type, tag = this.tagName.toLowerCase();\n\n\t\t\tif (re.test(t) || tag === 'textarea') {\n\t\t\t\tthis.value = '';\n\n\t\t\t} else if (t === 'checkbox' || t === 'radio') {\n\t\t\t\tthis.checked = false;\n\n\t\t\t} else if (tag === 'select') {\n\t\t\t\tthis.selectedIndex = -1;\n\n\t\t\t} else if (t === 'file') {\n\t\t\t\tif (/MSIE/.test(navigator.userAgent)) {\n\t\t\t\t\t$(this).replaceWith($(this).clone(true));\n\t\t\t\t} else {\n\t\t\t\t\t$(this).val('');\n\t\t\t\t}\n\n\t\t\t} else if (includeHidden) {\n\t\t\t\t// includeHidden can be the value true, or it can be a selector string\n\t\t\t\t// indicating a special test; for example:\n\t\t\t\t// $('#myForm').clearForm('.special:hidden')\n\t\t\t\t// the above would clean hidden inputs that have the class of 'special'\n\t\t\t\tif ((includeHidden === true && /hidden/.test(t)) ||\n\t\t\t\t\t(typeof includeHidden === 'string' && $(this).is(includeHidden))) {\n\t\t\t\t\tthis.value = '';\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\n\n\t/**\n\t * Resets the form data or individual elements. Takes the following actions\n\t * on the selected tags:\n\t * - all fields within form elements will be reset to their original value\n\t * - input / textarea / select fields will be reset to their original value\n\t * - option / optgroup fields (for multi-selects) will defaulted individually\n\t * - non-multiple options will find the right select to default\n\t * - label elements will be searched against its 'for' attribute\n\t * - all others will be searched for appropriate children to default\n\t */\n\t$.fn.resetForm = function() {\n\t\treturn this.each(function() {\n\t\t\tvar el = $(this);\n\t\t\tvar tag = this.tagName.toLowerCase();\n\n\t\t\tswitch (tag) {\n\t\t\tcase 'input':\n\t\t\t\tthis.checked = this.defaultChecked;\n\t\t\t\t\t// fall through\n\n\t\t\tcase 'textarea':\n\t\t\t\tthis.value = this.defaultValue;\n\n\t\t\t\treturn true;\n\n\t\t\tcase 'option':\n\t\t\tcase 'optgroup':\n\t\t\t\tvar select = el.parents('select');\n\n\t\t\t\tif (select.length && select[0].multiple) {\n\t\t\t\t\tif (tag === 'option') {\n\t\t\t\t\t\tthis.selected = this.defaultSelected;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tel.find('option').resetForm();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tselect.resetForm();\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\tcase 'select':\n\t\t\t\tel.find('option').each(function(i) {\t\t\t\t// eslint-disable-line consistent-return\n\t\t\t\t\tthis.selected = this.defaultSelected;\n\t\t\t\t\tif (this.defaultSelected && !el[0].multiple) {\n\t\t\t\t\t\tel[0].selectedIndex = i;\n\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn true;\n\n\t\t\tcase 'label':\n\t\t\t\tvar forEl = $(el.attr('for'));\n\t\t\t\tvar list = el.find('input,select,textarea');\n\n\t\t\t\tif (forEl[0]) {\n\t\t\t\t\tlist.unshift(forEl[0]);\n\t\t\t\t}\n\n\t\t\t\tlist.resetForm();\n\n\t\t\t\treturn true;\n\n\t\t\tcase 'form':\n\t\t\t\t\t// guard against an input with the name of 'reset'\n\t\t\t\t\t// note that IE reports the reset function as an 'object'\n\t\t\t\tif (typeof this.reset === 'function' || (typeof this.reset === 'object' && !this.reset.nodeType)) {\n\t\t\t\t\tthis.reset();\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\tdefault:\n\t\t\t\tel.find('form,input,label,select,textarea').resetForm();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t};\n\n\t/**\n\t * Enables or disables any matching elements.\n\t */\n\t$.fn.enable = function(b) {\n\t\tif (typeof b === 'undefined') {\n\t\t\tb = true;\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tthis.disabled = !b;\n\t\t});\n\t};\n\n\t/**\n\t * Checks/unchecks any matching checkboxes or radio buttons and\n\t * selects/deselects and matching option elements.\n\t */\n\t$.fn.selected = function(select) {\n\t\tif (typeof select === 'undefined') {\n\t\t\tselect = true;\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tvar t = this.type;\n\n\t\t\tif (t === 'checkbox' || t === 'radio') {\n\t\t\t\tthis.checked = select;\n\n\t\t\t} else if (this.tagName.toLowerCase() === 'option') {\n\t\t\t\tvar $sel = $(this).parent('select');\n\n\t\t\t\tif (select && $sel[0] && $sel[0].type === 'select-one') {\n\t\t\t\t\t// deselect all other options\n\t\t\t\t\t$sel.find('option').selected(false);\n\t\t\t\t}\n\n\t\t\t\tthis.selected = select;\n\t\t\t}\n\t\t});\n\t};\n\n\t// expose debug var\n\t$.fn.ajaxSubmit.debug = false;\n\n\t// helper fn for console logging\n\tfunction log() {\n\t\tif (!$.fn.ajaxSubmit.debug) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar msg = '[jquery.form] ' + Array.prototype.join.call(arguments, '');\n\n\t\tif (window.console && window.console.log) {\n\t\t\twindow.console.log(msg);\n\n\t\t} else if (window.opera && window.opera.postError) {\n\t\t\twindow.opera.postError(msg);\n\t\t}\n\t}\n}));\n\n\n//# sourceURL=webpack:///./.plone/++plone++static/components/jquery-form/src/jquery.form.js?");

/***/ }),

/***/ "./.plone/++plone++static/components/patternslib/src/core/base.js":
/*!************************************************************************!*\
  !*** ./.plone/++plone++static/components/patternslib/src/core/base.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * A Base pattern for creating scoped patterns. It's similar to Backbone's\n * Model class. The advantage of this approach is that each instance of a\n * pattern has its own local scope (closure).\n *\n * A new instance is created for each DOM element on which a pattern applies.\n *\n * You can assign values, such as $el, to `this` for an instance and they\n * will remain unique to that instance.\n *\n * Older Patternslib patterns on the other hand have a single global scope for\n * all DOM elements.\n */\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n  __webpack_require__(/*! jquery */ \"./.plone/++plone++static/components/jquery/dist/jquery.min.js\"),\n  __webpack_require__(/*! pat-registry */ \"./.plone/++plone++static/components/patternslib/src/core/registry.js\"),\n  __webpack_require__(/*! pat-mockup-parser */ \"./.plone/++plone++static/components/patternslib/src/core/mockup-parser.js\"),\n  __webpack_require__(/*! pat-logger */ \"./.plone/++plone++static/components/patternslib/src/core/logger.js\")\n], __WEBPACK_AMD_DEFINE_RESULT__ = (function($, Registry, mockupParser, logger) {\n    \"use strict\";\n    var log = logger.getLogger(\"Patternslib Base\");\n\n    var initBasePattern = function initBasePattern($el, options, trigger) {\n        var name = this.prototype.name;\n        var log = logger.getLogger(\"pat.\" + name);\n        var pattern = $el.data(\"pattern-\" + name);\n        if (pattern === undefined && Registry.patterns[name]) {\n            try {\n                options = this.prototype.parser  === \"mockup\" ? mockupParser.getOptions($el, name, options) : options;\n                pattern = new Registry.patterns[name]($el, options, trigger);\n            } catch (e) {\n                log.error(\"Failed while initializing '\" + name + \"' pattern.\", e);\n            }\n            $el.data(\"pattern-\" + name, pattern);\n        }\n        return pattern;\n    };\n\n    var Base = function($el, options, trigger) {\n        this.$el = $el;\n        this.options = $.extend(true, {}, this.defaults || {}, options || {});\n        this.init($el, options, trigger);\n        this.emit(\"init\");\n    };\n\n    Base.prototype = {\n        constructor: Base,\n        on: function(eventName, eventCallback) {\n            this.$el.on(eventName + \".\" + this.name + \".patterns\", eventCallback);\n        },\n        emit: function(eventName, args) {\n            // args should be a list\n            if (args === undefined) {\n                args = [];\n            }\n            this.$el.trigger(eventName + \".\" + this.name + \".patterns\", args);\n        }\n    };\n\n    Base.extend = function(patternProps) {\n        /* Helper function to correctly set up the prototype chain for new patterns.\n        */\n        var parent = this;\n        var child;\n\n        // Check that the required configuration properties are given.\n        if (!patternProps) {\n            throw new Error(\"Pattern configuration properties required when calling Base.extend\");\n        }\n\n        // The constructor function for the new subclass is either defined by you\n        // (the \"constructor\" property in your `extend` definition), or defaulted\n        // by us to simply call the parent's constructor.\n        if (patternProps.hasOwnProperty(\"constructor\")) {\n            child = patternProps.constructor;\n        } else {\n            child = function() { parent.apply(this, arguments); };\n        }\n\n        // Allow patterns to be extended indefinitely\n        child.extend = Base.extend;\n\n        // Static properties required by the Patternslib registry \n        child.init = initBasePattern;\n        child.jquery_plugin = true;\n        child.trigger = patternProps.trigger;\n\n        // Set the prototype chain to inherit from `parent`, without calling\n        // `parent`'s constructor function.\n        var Surrogate = function() { this.constructor = child; };\n        Surrogate.prototype = parent.prototype;\n        child.prototype = new Surrogate();\n\n        // Add pattern's configuration properties (instance properties) to the subclass,\n        $.extend(true, child.prototype, patternProps);\n\n        // Set a convenience property in case the parent's prototype is needed\n        // later.\n        child.__super__ = parent.prototype;\n\n        // Register the pattern in the Patternslib registry.\n        if (!patternProps.name) {\n            log.warn(\"This pattern without a name attribute will not be registered!\");\n        } else if (!patternProps.trigger) {\n            log.warn(\"The pattern '\"+patternProps.name+\"' does not \" +\n                     \"have a trigger attribute, it will not be registered.\");\n        } else {\n            Registry.register(child, patternProps.name);\n        }\n        return child;\n    };\n    return Base;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./.plone/++plone++static/components/patternslib/src/core/base.js?");

/***/ }),

/***/ "./.plone/++plone++static/components/patternslib/src/core/mockup-parser.js":
/*!*********************************************************************************!*\
  !*** ./.plone/++plone++static/components/patternslib/src/core/mockup-parser.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n    __webpack_require__(/*! jquery */ \"./.plone/++plone++static/components/jquery/dist/jquery.min.js\")\n], __WEBPACK_AMD_DEFINE_RESULT__ = (function($) {\n    'use strict';\n\n    var parser = {\n        getOptions: function getOptions($el, patternName, options) {\n            /* This is the Mockup parser. An alternative parser for Patternslib\n             * patterns.\n             *\n             * NOTE: Use of the Mockup parser is discouraged and is added here for\n             * legacy support for the Plone Mockup project.\n             *\n             * It parses a DOM element for pattern configuration options.\n             */\n            options = options || {};\n            // get options from parent element first, stop if element tag name is 'body'\n            if ($el.length !== 0 && !$.nodeName($el[0], 'body')) {\n                options = getOptions($el.parent(), patternName, options);\n            }\n            // collect all options from element\n            var elOptions = {};\n            if ($el.length !== 0) {\n                elOptions = $el.data('pat-' + patternName);\n                if (elOptions) {\n                    // parse options if string\n                    if (typeof(elOptions) === 'string') {\n                        var tmpOptions = {};\n                        $.each(elOptions.split(';'),\n                            function(i, item) {\n                                item = item.split(':');\n                                item.reverse();\n                                var key = item.pop();\n                                key = key.replace(/^\\s+|\\s+$/g, '');    // trim\n                                item.reverse();\n                                var value = item.join(':');\n                                value = value.replace(/^\\s+|\\s+$/g, '');    // trim\n                                tmpOptions[key] = value;\n                            }\n                        );\n                        elOptions = tmpOptions;\n                    }\n                }\n            }\n            return $.extend(true, {}, options, elOptions);\n        }\n    };\n    return parser;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./.plone/++plone++static/components/patternslib/src/core/mockup-parser.js?");

/***/ }),

/***/ "./.plone/++resource++mockup/autotoc/pattern.js":
/*!******************************************************!*\
  !*** ./.plone/++resource++mockup/autotoc/pattern.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* Autotoc pattern.\n *\n * Options:\n *    IDPrefix(string): Prefix used to generate ID. ('autotoc-item-')\n *    classActiveName(string): Class used for active level. ('active')\n *    classLevelPrefixName(string): Class prefix used for the TOC levels. ('autotoc-level-')\n *    classSectionName(string): Class used for section in TOC. ('autotoc-section')\n *    classTOCName(string): Class used for the TOC. ('autotoc-nav')\n *    levels(string): Selectors used to find levels. ('h1,h2,h3')\n *    scrollDuration(string): Speed of scrolling. ('slow')\n *    scrollEasing(string): Easing to use while scrolling. ('swing')\n *    section(string): Tag type to use for TOC. ('section')\n *\n * Documentation:\n *    # TOC\n *    {{ example-1 }}\n *\n *    # Tabs\n *    {{ example-2-tabs }}\n *\n * Example: example-1\n *    <div class=\"pat-autotoc\"\n *          data-pat-autotoc=\"scrollDuration:slow;levels:h4,h5,h6;\">\n *      <h4>Title 1</h4>\n *      <p>Mr. Zuckerkorn, you've been warned about touching. You said\n *         spanking. It walked on my pillow! How about a turtle? I've always\n *         loved those leathery little snappy faces.</p>\n *      <h5>Title 1.1</h5>\n *      <p>Ah coodle doodle do Caw ca caw, caw ca caw. Butterscotch!</p>\n *      <h6>Title 1.1.1</h6>\n *      <p>Want a lick? Okay, Lindsay, are you forgetting that I was\n *         a professional twice over - an analyst and a therapist.</p>\n *      <h4>Title 2</h4>\n *      <p>You boys know how to shovel coal? Don't worry, these young\n *      beauties have been nowhere near the bananas. I thought the two of\n *      us could talk man-on-man.</p>\n *    </div>\n *\n * Example: example-2-tabs\n *    <div class=\"pat-autotoc autotabs\"\n *          data-pat-autotoc=\"section:fieldset;levels:legend;\">\n *        <fieldset>\n *          <legend>Tab 1</legend>\n *          <div>\n *            Lorem ipsum dolor sit amet, ex nam odio ceteros fastidii,\n *            id porro lorem pro, homero facilisis in cum.\n *            At doming voluptua indoctum mel, natum noster similique ne mel.\n *          </div>\n *        </fieldset>\n *        <fieldset>\n *          <legend>Tab 2</legend>\n *          <div>\n *            Reque repudiare eum et. Prompta expetendis percipitur eu eam,\n *            et graece mandamus pro, eu vim harum audire tractatos.\n *            Ad perpetua salutandi mea, soluta delicata aliquando eam ne.\n *            Qui nostrum lucilius perpetua ut, eum suas stet oblique ut.\n *          </div>\n *        </fieldset>\n *        <fieldset>\n *          <legend>Tab 3</legend>\n *          <div>\n *            Vis mazim harum deterruisset ex, duo nemore nostro civibus ad,\n *            eros vituperata id cum. Vim at erat solet soleat,\n *            eum et iuvaret luptatum, pro an esse dolorum maiestatis.\n *          </div>\n *        </fieldset>\n *    </div>\n *\n */\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n  __webpack_require__(/*! jquery */ \"./.plone/++plone++static/components/jquery/dist/jquery.min.js\"),\n  __webpack_require__(/*! pat-base */ \"./.plone/++plone++static/components/patternslib/src/core/base.js\")\n], __WEBPACK_AMD_DEFINE_RESULT__ = (function($, Base) {\n  'use strict';\n\n  var AutoTOC = Base.extend({\n    name: 'autotoc',\n    trigger: '.pat-autotoc',\n    parser: 'mockup',\n    defaults: {\n      section: 'section',\n      levels: 'h1,h2,h3',\n      IDPrefix: 'autotoc-item-',\n      classTOCName: 'autotoc-nav',\n      classSectionName: 'autotoc-section',\n      classLevelPrefixName: 'autotoc-level-',\n      classActiveName: 'active',\n      scrollDuration: 'slow',\n      scrollEasing: 'swing'\n    },\n    init: function() {\n      var self = this;\n\n      self.$toc = $('<nav/>').addClass(self.options.classTOCName);\n\n      if (self.options.prependTo) {\n        self.$toc.prependTo(self.options.prependTo);\n      } else if (self.options.appendTo) {\n        self.$toc.appendTo(self.options.appendTo);\n      } else {\n        self.$toc.prependTo(self.$el);\n      }\n\n      if (self.options.className) {\n        self.$el.addClass(self.options.className);\n      }\n\n      $(self.options.section, self.$el).addClass(self.options.classSectionName);\n\n      var asTabs = self.$el.hasClass('autotabs');\n\n      var activeId = null;\n\n      $(self.options.levels, self.$el).each(function(i) {\n        var $level = $(this),\n            id = $level.prop('id') ? $level.prop('id') :\n                 $level.parents(self.options.section).prop('id');\n        if (!id || $('#' + id).length > 0) {\n          id = self.options.IDPrefix + self.name + '-' + i;\n        }\n        if(window.location.hash === '#' + id){\n          activeId = id;\n        }\n        if(activeId===null && $level.hasClass(self.options.classActiveName)){\n          activeId = id;\n        }\n        $level.data('navref', id);\n        $('<a/>')\n          .appendTo(self.$toc)\n          .text($level.text())\n          .attr('id', id)\n          .attr('href', '#' + id)\n          .addClass(self.options.classLevelPrefixName + self.getLevel($level))\n          .on('click', function(e, options) {\n            e.stopPropagation();\n            e.preventDefault();\n            if(!options){\n              options = {\n                doScroll: true,\n                skipHash: false\n              };\n            }\n            var $el = $(this);\n            self.$toc.children('.' + self.options.classActiveName).removeClass(self.options.classActiveName);\n            self.$el.children('.' + self.options.classActiveName).removeClass(self.options.classActiveName);\n            $(e.target).addClass(self.options.classActiveName);\n            $level.parents(self.options.section).addClass(self.options.classActiveName);\n            if (options.doScroll !== false &&\n                self.options.scrollDuration &&\n                $level &&\n                !asTabs) {\n              $('body,html').animate({\n                scrollTop: $level.offset().top\n              }, self.options.scrollDuration, self.options.scrollEasing);\n            }\n            if (self.$el.parents('.plone-modal').size() !== 0) {\n              self.$el.trigger('resize.plone-modal.patterns');\n            }\n            $(this).trigger('clicked');\n            if(!options.skipHash){\n              if(window.history && window.history.pushState){\n                window.history.pushState({}, '', '#' + $el.attr('id'));\n              }\n            }\n          });\n        $level.data('autotoc-trigger-id', id);\n      });\n\n      if(activeId){\n        $('a#' + activeId).trigger('click', {\n          doScroll: true,\n          skipHash: true\n        });\n      }else{\n        self.$toc.find('a').first().trigger('click', {\n          doScroll: false,\n          skipHash: true});\n      }\n    },\n    getLevel: function($el) {\n      var elementLevel = 0;\n      $.each(this.options.levels.split(','), function(level, levelSelector) {\n        if ($el.filter(levelSelector).size() === 1) {\n          elementLevel = level + 1;\n          return false;\n        }\n      });\n      return elementLevel;\n    }\n  });\n\n  return AutoTOC;\n\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./.plone/++resource++mockup/autotoc/pattern.js?");

/***/ }),

/***/ "./.plone/++resource++mockup/backdrop/pattern.js":
/*!*******************************************************!*\
  !*** ./.plone/++resource++mockup/backdrop/pattern.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* Backdrop pattern.\n *\n * Options:\n *    zIndex(integer): z-index of backdrop element. (null)\n *    opacity(float): opacity level of backdrop element. (0.8)\n *    className(string): class name of backdrop element. ('backdrop')\n *    classActiveName(string): class name when backdrop is active. ('backdrop-active')\n *    closeOnEsc(boolean): should backdrop close when ESC key is pressed. (true)\n *    closeOnClick(boolean): should backdrop close when clicked on it. (true)\n *\n * Documentation:\n *    # TODO: we need example or this is not pattern :)\n *\n * Example: example-1\n *\n */\n\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n  __webpack_require__(/*! jquery */ \"./.plone/++plone++static/components/jquery/dist/jquery.min.js\"),\n  __webpack_require__(/*! pat-base */ \"./.plone/++plone++static/components/patternslib/src/core/base.js\")\n], __WEBPACK_AMD_DEFINE_RESULT__ = (function($, Base) {\n  'use strict';\n\n  var Backdrop = Base.extend({\n    name: 'backdrop',\n    trigger: '.pat-backdrop',\n    parser: 'mockup',\n    defaults: {\n      zIndex: null,\n      opacity: 0.8,\n      className: 'plone-backdrop',\n      classActiveName: 'plone-backdrop-active',\n      closeOnEsc: true,\n      closeOnClick: true\n    },\n    init: function() {\n      var self = this;\n      self.$backdrop = $('> .' + self.options.className, self.$el);\n      if (self.$backdrop.size() === 0) {\n        self.$backdrop = $('<div/>')\n            .hide()\n            .appendTo(self.$el)\n            .addClass(self.options.className);\n        if (self.options.zIndex !== null) {\n          self.$backdrop.css('z-index', self.options.zIndex);\n        }\n      }\n      if (self.options.closeOnEsc === true) {\n        $(document).on('keydown', function(e, data) {\n          if (self.$el.is('.' + self.options.classActiveName)) {\n            if (e.keyCode === 27) {  // ESC key pressed\n              self.hide();\n            }\n          }\n        });\n      }\n      if (self.options.closeOnClick === true) {\n        self.$backdrop.on('click', function() {\n          if (self.$el.is('.' + self.options.classActiveName)) {\n            self.hide();\n          }\n        });\n      }\n    },\n    show: function() {\n      var self = this;\n      if (!self.$el.hasClass(self.options.classActiveName)) {\n        self.emit('show');\n        self.$backdrop.css('opacity', '0').show();\n        self.$el.addClass(self.options.classActiveName);\n        self.$backdrop.animate({ opacity: self.options.opacity }, 500);\n        self.emit('shown');\n      }\n    },\n    hide: function() {\n      var self = this;\n      if (self.$el.hasClass(self.options.classActiveName)) {\n        self.emit('hide');\n        self.$backdrop.animate({ opacity: '0' }, 500).hide();\n        self.$el.removeClass(self.options.classActiveName);\n        self.emit('hidden');\n      }\n    }\n  });\n\n  return Backdrop;\n\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./.plone/++resource++mockup/backdrop/pattern.js?");

/***/ }),

/***/ "./.plone/++resource++mockup/modal/pattern.js":
/*!****************************************************!*\
  !*** ./.plone/++resource++mockup/modal/pattern.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* Modal pattern.\n *\n * Options:\n *    height(string): Set the height of the modal, for example: 250px ('')\n *    width(string): Set the width of the modal, for example: 80% or 500px. ('')\n *    margin(function or integer): A function, Integer or String which will be used to set the margin of the modal in pixels. If a function is passed it must return an Integer. (20)\n *    position(string): Position the modal relative to the window with the format: \"<horizontal> <vertical>\" -- allowed values: top, bottom, left, right, center, middle. ('center middle')\n *    triggers(array): Add event listeners to elements on the page which will open the modal when triggered. Pass an Array of strings with the format [\"&lt;event&gt; &lt;selector&gt;\"] or [\"&lt;event&gt;\"]. For example, [\"click .someButton\"]. If you pass in only an event such as, [\"change\"], the event listener will be added to the element on which the modal was initiated, usually a link or button. ([])\n *    title(string): A string to place in the modal header. If title is provided, titleSelector is not used. (null)\n *    titleSelector(string): Selector for an element to extract from the content provided to the modal and place in the modal header. ('h1:first')\n *    content(string): Selector for an element within the content provided to the modal to use as the modal body. ('#content')\n *    prependContent(string): Selector for elements within the content provided to the modal which will be collected and inserted, by default above, the modal content. This is useful for extracting things like alerts or status messages on forms and displaying them to the user after an AJAX response. ('.portalMessage')\n *    backdrop(string): Selector for the element upon which the Backdrop pattern should be initiated. The Backdrop is a full width mask that will be apply above the content behind the modal which is useful for highlighting the modal dialog to the user. ('body')\n *    backdropOptions(object): Look at options at backdrop pattern. ({ zIndex: \"1040\", opacity: \"0.8\", className: \"backdrop\", classActiveName: \"backdrop-active\", closeOnEsc: true, closeOnClick: true })\n *    buttons(string): Selector for matching elements, usually buttons, inputs or links, from the modal content to place in the modal footer. The original elements in the content will be hidden. ('.formControls > input[type=\"submit\"]')\n *    automaticallyAddButtonActions(boolean): Automatically create actions for elements matched with the buttons selector. They will use the options provided in actionOptions. (true)\n *    loadLinksWithinModal(boolean): Automatically load links inside of the modal using AJAX. (true)\n *    actionOptions(object): A hash of selector to options. Where options can include any of the defaults from actionOptions. Allows for the binding of events to elements in the content and provides options for handling ajax requests and displaying them in the modal. ({})\n *\n *\n * Documentation:\n *    # Example\n *\n *    {{ example-basic }}\n *\n *    {{ example-long }}\n *\n *    {{ example-tinymce }}\n *\n *\n * Example: example-basic\n *    <a href=\"#modal1\" class=\"plone-btn plone-btn-large plone-btn-primary pat-plone-modal\"\n *                      data-pat-plone-modal=\"width: 400\">Modal basic</a>\n *    <div id=\"modal1\" style=\"display: none\">\n *      <h1>Basic modal!</h1>\n *      <p>Indeed. Whoa whoa whoa whoa. Wait.</p>\n *    </div>\n *\n * Example: example-long\n *    <a href=\"#modal2\" class=\"plone-btn plone-btn-lg plone-btn-primary pat-plone-modal\"\n *                      data-pat-plone-modal=\"width: 500\">Modal long scrolling</a>\n *    <div id=\"modal2\" style=\"display: none\">\n *      <h1>Basic with scrolling</h1>\n *      <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua</p>\n *      <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />\n *      <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua</p>\n *      <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />\n *      <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua</p>\n *      <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />\n *      <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua</p>\n *      <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />\n *      <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua</p>\n *      <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />\n *      <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua</p>\n *    </div>\n *\n *\n * Example: example-tinymce\n *    <a href=\"#modaltinymce\" class=\"btn btn-lg btn-primary pat-plone-modal\"\n *       data-pat-plone-modal=\"height: 600px;\n *                       width: 80%\">\n *       Modal with TinyMCE</a>\n *    <div id=\"modaltinymce\" style=\"display:none\">\n *      <textarea class=\"pat-tinymce\"></textarea>\n *    </div>\n *\n */\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n  __webpack_require__(/*! jquery */ \"./.plone/++plone++static/components/jquery/dist/jquery.min.js\"),\n  __webpack_require__(/*! underscore */ \"./.plone/++plone++static/components/underscore/underscore.js\"),\n  __webpack_require__(/*! pat-base */ \"./.plone/++plone++static/components/patternslib/src/core/base.js\"),\n  __webpack_require__(/*! mockup-patterns-backdrop */ \"./.plone/++resource++mockup/backdrop/pattern.js\"),\n  __webpack_require__(/*! pat-registry */ \"./.plone/++plone++static/components/patternslib/src/core/registry.js\"),\n  __webpack_require__(/*! mockup-router */ \"./.plone/++resource++mockupjs/router.js\"),\n  __webpack_require__(/*! mockup-utils */ \"./.plone/++resource++mockupjs/utils.js\"),\n  __webpack_require__(/*! translate */ \"./.plone/++resource++mockupjs/i18n-wrapper.js\"),\n  __webpack_require__(/*! jquery.form */ \"./.plone/++plone++static/components/jquery-form/src/jquery.form.js\")\n], __WEBPACK_AMD_DEFINE_RESULT__ = (function($, _, Base, Backdrop, registry, Router, utils, _t) {\n  'use strict';\n\n  var Modal = Base.extend({\n    name: 'plone-modal',\n    trigger: '.pat-plone-modal',\n    parser: 'mockup',\n    createModal: null,\n    $model: null,\n    defaults: {\n      width: '',\n      height: '',\n      margin: 20,\n      position: 'center middle', // format: '<horizontal> <vertical>' -- allowed values: top, bottom, left, right, center, middle\n      triggers: [],\n      zIndexSelector: '.plone-modal-wrapper,.plone-modal-backdrop',\n      backdrop: 'body', // Element to initiate the Backdrop on.\n      backdropOptions: {\n        zIndex: '1040',\n        opacity: '0.85',\n        className: 'plone-modal-backdrop',\n        classActiveName: 'plone-backdrop-active',\n        closeOnEsc: true,\n        closeOnClick: true\n      },\n      title: null,\n      titleSelector: 'h1:first',\n      buttons: '.formControls > input[type=\"submit\"]',\n      content: '#content',\n      automaticallyAddButtonActions: true,\n      loadLinksWithinModal: true,\n      prependContent: '.portalMessage',\n      templateOptions: {\n        className: 'plone-modal fade',\n        classDialog: 'plone-modal-dialog',\n        classModal: 'plone-modal-content',\n        classHeaderName: 'plone-modal-header',\n        classBodyName: 'plone-modal-body',\n        classFooterName: 'plone-modal-footer',\n        classWrapperName: 'plone-modal-wrapper',\n        classWrapperInnerName: 'modal-wrapper-inner',\n        classActiveName: 'in',\n        classPrependName: '', // String, css class to be applied to the wrapper of the prepended content\n        classContentName: '',  // String, class name to be applied to the content of the modal, useful for modal specific styling\n        template: '' +\n          '<div class=\"<%= options.className %>\">' +\n          '  <div class=\"<%= options.classDialog %>\">' +\n          '    <div class=\"<%= options.classModal %>\">' +\n          '      <div class=\"<%= options.classHeaderName %>\">' +\n          '        <a class=\"plone-modal-close\">&times;</a>' +\n          '        <% if (title) { %><h2 class=\"plone-modal-title\"><%= title %></h2><% } %>' +\n          '      </div>' +\n          '      <div class=\"<%= options.classBodyName %>\">' +\n          '        <div class=\"<%= options.classPrependName %>\"><%= prepend %></div> ' +\n          '        <div class=\"<%= options.classContentName %>\"><%= content %></div>' +\n          '      </div>' +\n          '      <div class=\"<%= options.classFooterName %>\"> ' +\n          '        <% if (buttons) { %><%= buttons %><% } %>' +\n          '      </div>' +\n          '    </div>' +\n          '  </div>' +\n          '</div>'\n      },\n      actions: {},\n      actionOptions: {\n        eventType: 'click',\n        disableAjaxFormSubmit: false,\n        target: null,\n        ajaxUrl: null, // string, or function($el, options) that returns a string\n        modalFunction: null, // String, function name on self to call\n        isForm: false,\n        timeout: 5000,\n        displayInModal: true,\n        reloadWindowOnClose: true,\n        error: '.portalMessage.error',\n        formFieldError: '.field.error',\n        onSuccess: null,\n        onError: null,\n        onFormError: null,\n        onTimeout: null,\n        redirectOnResponse: false,\n        redirectToUrl: function($action, response, options) {\n          var reg;\n          reg = /<body.*data-view-url=[\\\"'](.*)[\\\"'].*/im.exec(response);\n          if (reg && reg.length > 1) {\n            // view url as data attribute on body (Plone 5)\n            return reg[1].split('\"')[0];\n          }\n          reg = /<body.*data-base-url=[\\\"'](.*)[\\\"'].*/im.exec(response);\n          if (reg && reg.length > 1) {\n            // Base url as data attribute on body (Plone 5)\n            return reg[1].split('\"')[0];\n          }\n          reg = /<base.*href=[\\\"'](.*)[\\\"'].*/im.exec(response);\n          if (reg && reg.length > 1) {\n              // base tag available (Plone 4)\n              return reg[1];\n          }\n          return '';\n        }\n      },\n      routerOptions: {\n        id: null,\n        pathExp: null\n      },\n      form: function(actions) {\n        var self = this;\n        var $modal = self.$modal;\n\n        if (self.options.automaticallyAddButtonActions) {\n          actions[self.options.buttons] = {};\n        }\n        actions.a = {};\n\n        $.each(actions, function(action, options) {\n          var actionKeys = _.union(_.keys(self.options.actionOptions), ['templateOptions']);\n          var actionOptions = $.extend(true, {}, self.options.actionOptions, _.pick(options, actionKeys));\n          options.templateOptions = $.extend(true, options.templateOptions, self.options.templateOptions);\n\n          var patternKeys = _.union(_.keys(self.options.actionOptions), ['actions', 'actionOptions']);\n          var patternOptions = $.extend(true, _.omit(options, patternKeys), self.options);\n\n          $(action, $('.' + options.templateOptions.classBodyName, $modal)).each(function(action) {\n            var $action = $(this);\n            $action.on(actionOptions.eventType, function(e) {\n              e.stopPropagation();\n              e.preventDefault();\n\n              self.loading.show(false);\n\n              // handle event on $action using a function on self\n              if (actionOptions.modalFunction !== null) {\n                self[actionOptions.modalFunction]();\n              // handle event on input/button using jquery.form library\n              } else if ($.nodeName($action[0], 'input') || $.nodeName($action[0], 'button') || options.isForm === true) {\n                self.options.handleFormAction.apply(self, [$action, actionOptions, patternOptions]);\n              // handle event on link with jQuery.ajax\n              } else if (options.ajaxUrl !== null || $.nodeName($action[0], 'a')) {\n                self.options.handleLinkAction.apply(self, [$action, actionOptions, patternOptions]);\n              }\n\n            });\n          });\n        });\n      },\n      handleFormAction: function($action, options, patternOptions) {\n        var self = this;\n\n        // pass action that was clicked when submiting form\n        var extraData = {};\n        extraData[$action.attr('name')] = $action.attr('value');\n\n        var $form;\n\n        if ($.nodeName($action[0], 'form')) {\n          $form = $action;\n        } else {\n          $form = $action.parents('form:not(.disableAutoSubmit)');\n        }\n\n        var url;\n        if (options.ajaxUrl !== null) {\n          if (typeof options.ajaxUrl === 'function') {\n            url = options.ajaxUrl.apply(self, [$action, options]);\n          } else {\n            url = options.ajaxUrl;\n          }\n        } else {\n          url = $action.parents('form').attr('action');\n        }\n\n        if(options.disableAjaxFormSubmit){\n          if($action.attr('name') && $action.attr('value')){\n            $form.append($('<input type=\"hidden\" name=\"' + $action.attr('name') + '\" value=\"' + $action.attr('value') + '\" />'));\n          }\n          $form.trigger('submit');\n          return;\n        }\n        // We want to trigger the form submit event but NOT use the default\n        $form.on('submit', function(e) {\n          e.preventDefault();\n        });\n        $form.trigger('submit');\n\n        self.loading.show(false);\n        $form.ajaxSubmit({\n          timeout: options.timeout,\n          data: extraData,\n          url: url,\n          error: function(xhr, textStatus, errorStatus) {\n            self.loading.hide();\n            if (textStatus === 'timeout' && options.onTimeout) {\n              options.onTimeout.apply(self, xhr, errorStatus);\n            // on \"error\", \"abort\", and \"parsererror\"\n            } else if (options.onError) {\n              options.onError(xhr, textStatus, errorStatus);\n            } else {\n              // window.alert(_t('There was an error submitting the form.'));\n              console.log('error happened do something');\n            }\n            self.emit('formActionError', [xhr, textStatus, errorStatus]);\n          },\n          success: function(response, state, xhr, form) {\n            self.loading.hide();\n            // if error is found (NOTE: check for both the portal errors\n            // and the form field-level errors)\n            if ($(options.error, response).size() !== 0 ||\n                $(options.formFieldError, response).size() !== 0) {\n              if (options.onFormError) {\n                options.onFormError(self, response, state, xhr, form);\n              } else {\n                self.redraw(response, patternOptions);\n              }\n              return;\n            }\n\n            if (options.redirectOnResponse === true) {\n              if (typeof options.redirectToUrl === 'function') {\n                window.parent.location.href = options.redirectToUrl.apply(self, [$action, response, options]);\n              } else {\n                window.parent.location.href = options.redirectToUrl;\n              }\n              return; // cut out right here since we're changing url\n            }\n\n            if (options.onSuccess) {\n              options.onSuccess(self, response, state, xhr, form);\n            }\n\n            if (options.displayInModal === true) {\n              self.redraw(response, patternOptions);\n            } else {\n              $action.trigger('destroy.plone-modal.patterns');\n              // also calls hide\n              if (options.reloadWindowOnClose) {\n                self.reloadWindow();\n              }\n            }\n            self.emit('formActionSuccess', [response, state, xhr, form]);\n          }\n        });\n      },\n      handleLinkAction: function($action, options, patternOptions) {\n        var self = this;\n        var url;\n\n        // Figure out URL\n        if (options.ajaxUrl) {\n          if (typeof options.ajaxUrl === 'function') {\n            url = options.ajaxUrl.apply(self, [$action, options]);\n          } else {\n            url = options.ajaxUrl;\n          }\n        } else {\n          url = $action.attr('href');\n        }\n\n        // Non-ajax link (I know it says \"ajaxUrl\" ...)\n        if (options.displayInModal === false) {\n          if($action.attr('target') === '_blank'){\n            window.open(url, '_blank');\n            self.loading.hide();\n          }else{\n            window.location = url;\n          }\n          return;\n        }\n\n        // ajax version\n        $.ajax({\n          url: url\n        }).fail(function(xhr, textStatus, errorStatus) {\n          if (textStatus === 'timeout' && options.onTimeout) {\n            options.onTimeout(self.$modal, xhr, errorStatus);\n\n          // on \"error\", \"abort\", and \"parsererror\"\n          } else if (options.onError) {\n            options.onError(xhr, textStatus, errorStatus);\n          } else {\n            window.alert(_t('There was an error loading modal.'));\n          }\n          self.emit('linkActionError', [xhr, textStatus, errorStatus]);\n        }).done(function(response, state, xhr) {\n          self.redraw(response, patternOptions);\n          if (options.onSuccess) {\n            options.onSuccess(self, response, state, xhr);\n          }\n          self.emit('linkActionSuccess', [response, state, xhr]);\n        }).always(function(){\n          self.loading.hide();\n        });\n      },\n      render: function(options) {\n        var self = this;\n\n        self.emit('before-render');\n\n        if (!self.$raw) {\n          return;\n        }\n        var $raw = self.$raw.clone();\n        // fix for IE9 bug (see http://bugs.jquery.com/ticket/10550)\n        $('input:checked', $raw).each(function() {\n          if (this.setAttribute) {\n            this.setAttribute('checked', 'checked');\n          }\n        });\n\n        // Object that will be passed to the template\n        var tplObject = {\n          title: '',\n          prepend: '<div />',\n          content: '',\n          buttons: '<div class=\"pattern-modal-buttons\"></div>',\n          options: options.templateOptions\n        };\n\n        // setup the Title\n        if (options.title === null) {\n          var $title = $(options.titleSelector, $raw);\n          tplObject.title = $title.html();\n          $(options.titleSelector, $raw).remove();\n        } else {\n          tplObject.title = options.title;\n        }\n\n        // Grab items to to insert into the prepend area\n        if (options.prependContent) {\n          tplObject.prepend = $('<div />').append($(options.prependContent, $raw).clone()).html();\n          $(options.prependContent, $raw).remove();\n        }\n\n        // Filter out the content if there is a selector provided\n        if (options.content) {\n          tplObject.content = $(options.content, $raw).html();\n        } else {\n          tplObject.content = $raw.html();\n        }\n\n        // Render html\n        self.$modal = $(_.template(self.options.templateOptions.template)(tplObject));\n        self.$modalDialog = $('> .' + self.options.templateOptions.classDialog, self.$modal);\n        self.$modalContent = $('> .' + self.options.templateOptions.classModal, self.$modalDialog);\n\n        // In most browsers, when you hit the enter key while a form element is focused\n        // the browser will trigger the form 'submit' event.  Google Chrome also does this,\n        // but not when when the default submit button is hidden with 'display: none'.\n        // The following code will work around this issue:\n        $('form', self.$modal).on ('keydown', function (event) {\n          // ignore keys which are not enter, and ignore enter inside a textarea.\n          if (event.keyCode !== 13 || event.target.nodeName === 'TEXTAREA') {\n            return;\n          }\n          event.preventDefault();\n          $('input[type=submit], button[type=submit], button:not(type)', this).eq(0).trigger('click');\n        });\n\n        // Setup buttons\n        $(options.buttons, self.$modal).each(function() {\n          var $button = $(this);\n          $button\n            .on('click', function(e) {\n              e.stopPropagation();\n              e.preventDefault();\n            })\n            .clone()\n            .appendTo($('.pattern-modal-buttons', self.$modal))\n            .off('click').on('click', function(e) {\n              e.stopPropagation();\n              e.preventDefault();\n              $button.trigger('click');\n            });\n          $button.hide();\n        });\n\n        self.emit('before-events-setup');\n\n        // Wire up events\n        $('.plone-modal-header > a.plone-modal-close, .plone-modal-footer > a.plone-modal-close', self.$modal)\n          .off('click')\n          .on('click', function(e) {\n            e.stopPropagation();\n            e.preventDefault();\n            $(e.target).trigger('destroy.plone-modal.patterns');\n          });\n\n        // form\n        if (options.form) {\n          options.form.apply(self, [options.actions]);\n        }\n\n        self.$modal\n          .addClass(self.options.templateOptions.className)\n          .on('destroy.plone-modal.patterns', function(e) {\n            e.stopPropagation();\n            self.hide();\n          })\n          .on('resize.plone-modal.patterns', function(e) {\n            e.stopPropagation();\n            e.preventDefault();\n            self.positionModal();\n          })\n          .appendTo(self.$wrapperInner);\n\n        if (self.options.loadLinksWithinModal) {\n          self.$modal.on('click', function(e) {\n            e.stopPropagation();\n            if ($.nodeName(e.target, 'a')) {\n              e.preventDefault();\n              // TODO: open links inside modal\n              // and slide modal body\n            }\n            self.$modal.trigger('modal-click');\n          });\n        }\n        self.$modal.data('pattern-' + self.name, self);\n        self.emit('after-render');\n      }\n    },\n    reloadWindow: function() {\n      window.parent.location.reload();\n    },\n    init: function() {\n      var self = this;\n      self.options.loadLinksWithinModal = $.parseJSON(self.options.loadLinksWithinModal);\n\n      // Router\n      if (self.options.routerOptions.id !== null) {\n        Router.addRoute('modal', self.options.routerOptions.id, function() {\n          this.show();\n        }, self, self.options.routerOptions.pathExp, self.options.routerOptions.expReplace);\n      }\n\n      if (self.options.backdropOptions.closeOnEsc === true) {\n        $(document).on('keydown', function(e, data) {\n          if (self.$el.is('.' + self.options.templateOptions.classActiveName)) {\n            if (e.keyCode === 27) {  // ESC key pressed\n              self.hide();\n            }\n          }\n        });\n      }\n\n\n\n\n      $(window.parent).resize(function() {\n        self.positionModal();\n      });\n\n      if (self.options.triggers) {\n        $.each(self.options.triggers, function(i, item) {\n          var e = item.substring(0, item.indexOf(' '));\n          var selector = item.substring(item.indexOf(' '), item.length);\n          $(selector || self.$el).on(e, function(e) {\n            e.stopPropagation();\n            e.preventDefault();\n            self.show();\n          });\n        });\n      }\n\n      if (self.$el.is('a')) {\n        if (self.$el.attr('href') && !self.options.image) {\n          if (!self.options.target && self.$el.attr('href').substr(0, 1) === '#') {\n            self.options.target = self.$el.attr('href');\n            self.options.content = '';\n          }\n          if (!self.options.ajaxUrl && self.$el.attr('href').substr(0, 1) !== '#') {\n            self.options.ajaxUrl = function () {\n              // Resolve ``href`` attribute later, when modal is shown.\n              return self.$el.attr('href');\n            };\n          }\n        }\n        self.$el.on('click', function(e) {\n          e.stopPropagation();\n          e.preventDefault();\n          self.show();\n        });\n      }\n      self.initModal();\n    },\n\n    createAjaxModal: function() {\n      var self = this;\n      self.emit('before-ajax');\n      self.loading.show();\n\n      var ajaxUrl = self.options.ajaxUrl;\n      if (typeof ajaxUrl === 'function') {\n        ajaxUrl = ajaxUrl.apply(self, [self.options]);\n      }\n\n      self.ajaxXHR = $.ajax({\n        url: ajaxUrl,\n        type: self.options.ajaxType\n      }).done(function(response, textStatus, xhr) {\n        self.ajaxXHR = undefined;\n        self.$raw = $('<div />').append($(utils.parseBodyTag(response)));\n        self.emit('after-ajax', self, textStatus, xhr);\n        self._show();\n      }).fail(function(xhr, textStatus, errorStatus){\n        var options = self.options.actionOptions;\n        if (textStatus === 'timeout' && options.onTimeout) {\n          options.onTimeout(self.$modal, xhr, errorStatus);\n        } else if (options.onError) {\n          options.onError(xhr, textStatus, errorStatus);\n        } else {\n          window.alert(_t('There was an error loading modal.'));\n          self.hide();\n        }\n        self.emit('linkActionError', [xhr, textStatus, errorStatus]);\n      }).always(function(){\n        self.loading.hide();\n      });\n    },\n\n    createTargetModal: function() {\n      var self = this;\n      self.$raw = $(self.options.target).clone();\n      self._show();\n    },\n\n    createBasicModal: function() {\n      var self = this;\n      self.$raw = $('<div/>').html(self.$el.clone());\n      self._show();\n    },\n\n    createHtmlModal: function() {\n      var self = this;\n      var $el = $(self.options.html);\n      self.$raw = $el;\n      self._show();\n    },\n\n    createImageModal: function(){\n      var self = this;\n      self.$wrapper.addClass('image-modal');\n      var src = self.$el.attr('href');\n      var srcset = self.$el.attr('data-modal-srcset') || '';\n      var title = $.trim(self.$el.context.innerText) || 'Image';\n      // XXX aria?\n      self.$raw = $('<div><h1>' + title + '</h1><div id=\"content\"><div class=\"modal-image\"><img src=\"' + src + '\" srcset=\"' + srcset + '\" /></div></div></div>');\n      self._show();\n    },\n\n    initModal: function() {\n      var self = this;\n      if (self.options.ajaxUrl) {\n        self.createModal = self.createAjaxModal;\n      } else if (self.options.target) {\n        self.createModal = self.createTargetModal;\n      } else if (self.options.html) {\n        self.createModal = self.createHtmlModal;\n      } else if (self.options.image){\n        self.createModal = self.createImageModal;\n      } else {\n        self.createModal = self.createBasicModal;\n      }\n    },\n\n    findPosition: function(horpos, vertpos, margin, modalWidth, modalHeight,\n                           wrapperInnerWidth, wrapperInnerHeight) {\n      var returnpos = {};\n      var absTop, absBottom, absLeft, absRight;\n      absRight = absLeft = absTop = absLeft = 'auto';\n\n      // -- HORIZONTAL POSITION -----------------------------------------------\n      if (horpos === 'left') {\n        absLeft = margin + 'px';\n        // if the width of the wrapper is smaller than the modal, and thus the\n        // screen is smaller than the modal, force the left to simply be 0\n        if (modalWidth > wrapperInnerWidth) {\n          absLeft = '0px';\n        }\n        returnpos.left = absLeft;\n      }\n      else if (horpos === 'right') {\n        absRight =  margin + 'px';\n        // if the width of the wrapper is smaller than the modal, and thus the\n        // screen is smaller than the modal, force the right to simply be 0\n        if (modalWidth > wrapperInnerWidth) {\n          absRight = '0px';\n        }\n        returnpos.right = absRight;\n        returnpos.left = 'auto';\n      }\n      // default, no specified location, is to center\n      else {\n        absLeft = ((wrapperInnerWidth / 2) - (modalWidth / 2) - margin) + 'px';\n        // if the width of the wrapper is smaller than the modal, and thus the\n        // screen is smaller than the modal, force the left to simply be 0\n        if (modalWidth > wrapperInnerWidth) {\n          absLeft = '0px';\n        }\n        returnpos.left = absLeft;\n      }\n\n      // -- VERTICAL POSITION -------------------------------------------------\n      if (vertpos === 'top') {\n        absTop = margin + 'px';\n        // if the height of the wrapper is smaller than the modal, and thus the\n        // screen is smaller than the modal, force the top to simply be 0\n        if (modalHeight > wrapperInnerHeight) {\n          absTop = '0px';\n        }\n        returnpos.top = absTop;\n      }\n      else if (vertpos === 'bottom') {\n        absBottom = margin + 'px';\n        // if the height of the wrapper is smaller than the modal, and thus the\n        // screen is smaller than the modal, force the bottom to simply be 0\n        if (modalHeight > wrapperInnerHeight) {\n          absBottom = '0px';\n        }\n        returnpos.bottom = absBottom;\n        returnpos.top = 'auto';\n      }\n      else {\n        // default case, no specified location, is to center\n        absTop = ((wrapperInnerHeight / 2) - (modalHeight / 2) - margin) + 'px';\n        // if the height of the wrapper is smaller than the modal, and thus the\n        // screen is smaller than the modal, force the top to simply be 0\n        if (modalHeight > wrapperInnerHeight) {\n          absTop = '0px';\n        }\n        returnpos.top = absTop;\n      }\n      return returnpos;\n    },\n\n    modalInitialized: function() {\n      var self = this;\n      return self.$modal !== null && self.$modal !== undefined;\n    },\n\n    positionModal: function() {\n      /* re-position modal at any point.\n       *\n       * Uses:\n       *  options.margin\n       *  options.width\n       *  options.height\n       *  options.position\n       */\n      var self = this;\n      // modal isn't initialized\n      if (!self.modalInitialized()) { return; }\n      // clear out any previously set styling\n      self.$modal.removeAttr('style');\n\n      // if backdrop wrapper is set on body, then wrapper should have height of\n      // the window, so we can do scrolling of inner wrapper\n      if (self.$wrapper.parent().is('body')) {\n        self.$wrapper.height($(window.parent).height());\n      }\n\n      var margin = typeof self.options.margin === 'function' ? self.options.margin() : self.options.margin;\n      self.$modal.css({\n        'position': 'absolute',\n        'padding': margin\n      });\n      self.$modalDialog.css({\n        margin: '0',\n        padding: '0',\n        width: self.options.width, // defaults to \"\", which doesn't override other css\n        height: self.options.height // defaults to \"\", which doesn't override other css\n      });\n      self.$modalContent.css({\n        width: self.options.width, // defaults to \"\", which doesn't override other css\n      });\n\n      var posopt = self.options.position.split(' '),\n          horpos = posopt[0],\n          vertpos = posopt[1];\n      var modalWidth = self.$modalDialog.outerWidth(true);\n      var modalHeight = self.$modalDialog.outerHeight(true);\n      var wrapperInnerWidth = self.$wrapperInner.width();\n      var wrapperInnerHeight = self.$wrapperInner.height();\n      var pos = self.findPosition(\n        horpos, vertpos, margin, modalWidth, modalHeight,\n        wrapperInnerWidth, wrapperInnerHeight\n      );\n      for (var key in pos) {\n        self.$modalDialog.css(key, pos[key]);\n      }\n    },\n\n    render: function(options) {\n      var self = this;\n      self.emit('render');\n      self.options.render.apply(self, [options]);\n      self.emit('rendered');\n    },\n\n    show: function() {\n      var self = this;\n      self.backdrop = self.createBackdrop();\n      self.createModal();\n    },\n\n    createBackdrop: function() {\n      var self = this,\n          backdrop = new Backdrop(\n            self.$el.parents(self.options.backdrop),\n            self.options.backdropOptions\n          ),\n          zIndex = 1041;\n\n      $(self.options.zIndexSelector).each(function(){\n        zIndex = Math.max(zIndex, parseInt($(this).css('zIndex')) + 1 || 1041);\n      });\n\n      self.$wrapper = $('<div/>')\n        .hide()\n        .css({\n          'z-index': zIndex,\n          'overflow-y': 'auto',\n          'position': 'fixed',\n          'height': '100%',\n          'width': '100%',\n          'bottom': '0',\n          'left': '0',\n          'right': '0',\n          'top': '0'\n        })\n        .addClass(self.options.templateOptions.classWrapperName)\n        .insertBefore(backdrop.$backdrop)\n        .on('click', function(e) {\n          if (self.options.backdropOptions.closeOnClick) {\n            e.stopPropagation();\n            e.preventDefault();\n            backdrop.hide();\n          }\n        });\n      backdrop.on('hidden', function(e) {\n        if (self.$modal !== undefined && self.$modal.hasClass(self.options.templateOptions.classActiveName)) {\n          self.hide();\n        }\n      });\n      self.loading = new utils.Loading({\n        'backdrop': backdrop\n      });\n      self.$wrapperInner = $('<div/>')\n        .addClass(self.options.classWrapperInnerName)\n        .css({\n          'position': 'absolute',\n          'bottom': '0',\n          'left': '0',\n          'right': '0',\n          'top': '0'\n        })\n        .appendTo(self.$wrapper);\n      return backdrop;\n    },\n\n    _show: function() {\n      var self = this;\n      self.render.apply(self, [ self.options ]);\n      self.emit('show');\n      self.backdrop.show();\n      self.$wrapper.show();\n      self.loading.hide();\n      self.$el.addClass(self.options.templateOptions.classActiveName);\n      self.$modal.addClass(self.options.templateOptions.classActiveName);\n      registry.scan(self.$modal);\n      self.positionModal();\n      $(window.parent).on('resize.plone-modal.patterns', function() {\n        self.positionModal();\n      });\n      $('body').addClass('plone-modal-open');\n      self.emit('shown');\n    },\n    hide: function() {\n      var self = this;\n      if (self.ajaxXHR) {\n        self.ajaxXHR.abort();\n      }\n      self.emit('hide');\n      if (self._suppressHide) {\n        if (!window.confirm(self._suppressHide)) {\n          return;\n        }\n      }\n      self.loading.hide();\n      self.$el.removeClass(self.options.templateOptions.classActiveName);\n      if (self.$modal !== undefined) {\n        self.$modal.remove();\n        self.initModal();\n      }\n      self.$wrapper.remove();\n      if ($('.plone-modal', $('body')).size() < 1) {\n        self._suppressHide = undefined;\n        self.backdrop.hide();\n        $('body').removeClass('plone-modal-open');\n        $(window.parent).off('resize.plone-modal.patterns');\n      }\n      self.emit('hidden');\n    },\n\n    redraw: function(response, options) {\n      var self = this;\n      self.emit('beforeDraw');\n      self.$modal.remove();\n      self.$raw = $('<div />').append($(utils.parseBodyTag(response)));\n      self.render.apply(self, [options || self.options]);\n      self.$modal.addClass(self.options.templateOptions.classActiveName);\n      self.positionModal();\n      registry.scan(self.$modal);\n      self.emit('afterDraw');\n    }\n  });\n\n  return Modal;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./.plone/++resource++mockup/modal/pattern.js?");

/***/ }),

/***/ "./.plone/++resource++mockupjs/i18n-wrapper.js":
/*!*****************************************************!*\
  !*** ./.plone/++resource++mockupjs/i18n-wrapper.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* i18n integration.\n *\n * This is a singleton.\n * Configuration is done on the body tag data-i18ncatalogurl attribute\n *     <body data-i18ncatalogurl=\"/plonejsi18n\">\n *\n *  Or, it'll default to \"/plonejsi18n\"\n */\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n  __webpack_require__(/*! mockup-i18n */ \"./.plone/++resource++mockupjs/i18n.js\")\n], __WEBPACK_AMD_DEFINE_RESULT__ = (function(I18N) {\n  'use strict';\n\n  // we're creating a singleton here so we can potentially\n  // delay the initialization of the translate catalog\n  // until after the dom is available\n  var _t = null;\n  return function(msgid, keywords) {\n    if (_t === null) {\n      var i18n = new I18N();\n      i18n.loadCatalog('widgets');\n      _t = i18n.MessageFactory('widgets');\n    }\n    return _t(msgid, keywords);\n  };\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./.plone/++resource++mockupjs/i18n-wrapper.js?");

/***/ }),

/***/ "./.plone/++resource++mockupjs/i18n.js":
/*!*********************************************!*\
  !*** ./.plone/++resource++mockupjs/i18n.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* i18n integration. This is forked from jarn.jsi18n\n *\n * This is a singleton.\n * Configuration is done on the body tag data-i18ncatalogurl attribute\n *     <body data-i18ncatalogurl=\"/plonejsi18n\">\n *\n *  Or, it'll default to \"/plonejsi18n\"\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n  __webpack_require__(/*! jquery */ \"./.plone/++plone++static/components/jquery/dist/jquery.min.js\")\n], __WEBPACK_AMD_DEFINE_RESULT__ = (function($) {\n  'use strict';\n\n  var I18N = function() {\n    var self = this;\n    self.baseUrl = $('body').attr('data-i18ncatalogurl');\n    self.currentLanguage = $('html').attr('lang') || 'en';\n\n    // Fix for country specific languages\n    if (self.currentLanguage.split('-').length > 1) {\n      self.currentLanguage = self.currentLanguage.split('-')[0] + '_' + self.currentLanguage.split('-')[1].toUpperCase();\n    }\n\n    self.storage = null;\n    self.catalogs = {};\n    self.ttl = 24 * 3600 * 1000;\n\n    // Internet Explorer 8 does not know Date.now() which is used in e.g. loadCatalog, so we \"define\" it\n    if (!Date.now) {\n      Date.now = function() {\n        return new Date().valueOf();\n      };\n    }\n\n    try {\n      if ('localStorage' in window && window.localStorage !== null && 'JSON' in window && window.JSON !== null) {\n        self.storage = window.localStorage;\n      }\n    } catch (e) {}\n\n    self.configure = function(config) {\n      for (var key in config){\n        self[key] = config[key];\n      }\n    };\n\n    self._setCatalog = function (domain, language, catalog) {\n      if (domain in self.catalogs) {\n        self.catalogs[domain][language] = catalog;\n      } else {\n        self.catalogs[domain] = {};\n        self.catalogs[domain][language] = catalog;\n      }\n    };\n\n    self._storeCatalog = function (domain, language, catalog) {\n      var key = domain + '-' + language;\n      if (self.storage !== null && catalog !== null) {\n        self.storage.setItem(key, JSON.stringify(catalog));\n        self.storage.setItem(key + '-updated', Date.now());\n      }\n    };\n\n    self.getUrl = function(domain, language) {\n      return self.baseUrl + '?domain=' + domain + '&language=' + language;\n    };\n\n    self.loadCatalog = function (domain, language) {\n      if (language === undefined) {\n        language = self.currentLanguage;\n      }\n      if (self.storage !== null) {\n        var key = domain + '-' + language;\n        if (key in self.storage) {\n          if ((Date.now() - parseInt(self.storage.getItem(key + '-updated'), 10)) < self.ttl) {\n            var catalog = JSON.parse(self.storage.getItem(key));\n            self._setCatalog(domain, language, catalog);\n            return;\n          }\n        }\n      }\n      if (!self.baseUrl) {\n        return;\n      }\n      $.getJSON(self.getUrl(domain, language), function (catalog) {\n        if (catalog === null) {\n          return;\n        }\n        self._setCatalog(domain, language, catalog);\n        self._storeCatalog(domain, language, catalog);\n      });\n    };\n\n    self.MessageFactory = function (domain, language) {\n      language = language || self.currentLanguage;\n      return function translate (msgid, keywords) {\n        var msgstr;\n        if ((domain in self.catalogs) && (language in self.catalogs[domain]) && (msgid in self.catalogs[domain][language])) {\n          msgstr = self.catalogs[domain][language][msgid];\n        } else {\n          msgstr = msgid;\n        }\n        if (keywords) {\n          var regexp, keyword;\n          for (keyword in keywords) {\n            if (keywords.hasOwnProperty(keyword)) {\n              regexp = new RegExp('\\\\$\\\\{' + keyword + '\\\\}', 'g');\n              msgstr = msgstr.replace(regexp, keywords[keyword]);\n            }\n          }\n        }\n        return msgstr;\n      };\n    };\n  };\n\n  return I18N;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./.plone/++resource++mockupjs/i18n.js?");

/***/ }),

/***/ "./.plone/++resource++mockupjs/router.js":
/*!***********************************************!*\
  !*** ./.plone/++resource++mockupjs/router.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* Pattern router\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n  __webpack_require__(/*! underscore */ \"./.plone/++plone++static/components/underscore/underscore.js\"),\n  __webpack_require__(/*! backbone */ \"./.plone/++plone++static/components/backbone/backbone.js\")\n], __WEBPACK_AMD_DEFINE_RESULT__ = (function(_, Backbone) {\n  'use strict';\n\n  var regexEscape = function(s) {\n    return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n  };\n\n  var Router = Backbone.Router.extend({\n    actions: [],\n    redirects: {},\n    addRoute: function(patternName, id, callback, context, pathExp, expReplace) {\n      if (_.findWhere(this.patterns, {patternName: patternName, id: id}) === undefined) {\n        this.actions.push({patternName: patternName, id: id, callback: callback, context: context, pathExp: pathExp, expReplace: expReplace});\n      }\n      var regex = new RegExp('(' + regexEscape(patternName) + ':' + regexEscape(id) + ')');\n      this.route(regex, 'handleRoute');\n    },\n    addRedirect: function(pathExp, destination) {\n      this.redirects[pathExp] = destination;\n    },\n    handleRoute: function(pattern) {\n      var parts = pattern.split(':');\n      var patternName = parts[0];\n      var id = parts[1];\n      var action = _.findWhere(this.actions, {patternName: patternName, id: id});\n      if (action) {\n        action.callback.call(action.context);\n      }\n    },\n    redirect: function() {\n      var path = window.parent.location.pathname,\n          newPath,\n          regex,\n          hash;\n\n      _.some(this.actions, function(action) {\n        if (action.pathExp) {\n          regex = new RegExp(action.pathExp);\n          if (path.match(regex)) {\n            hash = '!/' + action.patternName + ':' + action.id;\n            var replaceWith = '';\n            if (action.expReplace) {\n              replaceWith = action.expReplace;\n            }\n            newPath = path.replace(regex, replaceWith);\n            return true;\n          }\n        }\n      }, this);\n\n      if (hash === undefined) {\n        for (var pathExp in this.redirects) {\n          regex = new RegExp(pathExp);\n          if (path.match(regex)) {\n            hash = '!/' + this.redirects[pathExp];\n            newPath = path.replace(regex, '');\n            break;\n          }\n        }\n      }\n\n      if (hash !== undefined) {\n        this._changeLocation.apply(this, [newPath, hash]);\n      }\n    },\n    _changeLocation: function(path, hash) {\n      window.parent.location.hash = hash;\n      window.parent.location.pathname = path;\n    },\n    start: function() {\n      Backbone.history.start();\n    },\n    reset: function() {\n      this.actions = [];\n    }\n\n  });\n\n  return new Router();\n\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./.plone/++resource++mockupjs/router.js?");

/***/ }),

/***/ "./.plone/++resource++mockupjs/utils.js":
/*!**********************************************!*\
  !*** ./.plone/++resource++mockupjs/utils.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*** IMPORTS FROM imports-loader ***/\nvar jQuery = __webpack_require__(/*! jquery */ \"./.plone/++plone++static/components/jquery/dist/jquery.min.js\");\nvar $ = __webpack_require__(/*! jquery */ \"./.plone/++plone++static/components/jquery/dist/jquery.min.js\");\n\n/* Pattern utils\n */\n\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n  __webpack_require__(/*! jquery */ \"./.plone/++plone++static/components/jquery/dist/jquery.min.js\")\n], __WEBPACK_AMD_DEFINE_RESULT__ = (function($) {\n  'use strict';\n\n  var QueryHelper = function(options) {\n    /* if pattern argument provided, it can implement the interface of:\n     *    - browsing: boolean if currently browsing\n     *    - currentPath: string of current path to apply to search if browsing\n     *    - basePath: default path to provide if no subpath used\n     */\n\n    var self = this;\n    var defaults = {\n      pattern: null, // must be passed in\n      vocabularyUrl: null,\n      searchParam: 'SearchableText', // query string param to pass to search url\n      pathOperator: 'plone.app.querystring.operation.string.path',\n      attributes: ['UID', 'Title', 'Description', 'getURL', 'portal_type'],\n      batchSize: 10, // number of results to retrive\n      baseCriteria: [],\n      sort_on: 'is_folderish',\n      sort_order: 'reverse',\n      pathDepth: 1\n    };\n    self.options = $.extend({}, defaults, options);\n\n    self.pattern = self.options.pattern;\n    if (self.pattern === undefined || self.pattern === null) {\n      self.pattern = {\n        browsing: false,\n        basePath: '/'\n      };\n    }\n\n    if (self.options.url && !self.options.vocabularyUrl) {\n      self.options.vocabularyUrl = self.options.url;\n    } else if (self.pattern.vocabularyUrl) {\n      self.options.vocabularyUrl = self.pattern.vocabularyUrl;\n    }\n    self.valid = Boolean(self.options.vocabularyUrl);\n\n    self.getBatch = function(page) {\n      return {\n        page: page ? page : 1,\n        size: self.options.batchSize\n      };\n    };\n\n    self.getCurrentPath = function() {\n      var pattern = self.pattern;\n      var currentPath;\n      /* If currentPath is set on the QueryHelper object, use that first.\n       * Then, check on the pattern.\n       * Finally, see if it is a function and call it if it is.\n       */\n      if (self.currentPath) {\n        currentPath = self.currentPath;\n      } else {\n        currentPath = pattern.currentPath;\n      }\n      if (typeof currentPath === 'function') {\n        currentPath = currentPath();\n      }\n      var path = currentPath;\n      if (!path) {\n        if (pattern.basePath) {\n          path = pattern.basePath;\n        } else if (pattern.options.basePath) {\n          path = pattern.options.basePath;\n        } else {\n          path = '/';\n        }\n      }\n      return path;\n    };\n\n    self.getCriterias = function(term, searchOptions) {\n      if (searchOptions === undefined) {\n        searchOptions = {};\n      }\n      searchOptions = $.extend({}, {\n        useBaseCriteria: true,\n        additionalCriterias: []\n      }, searchOptions);\n\n      var criterias = [];\n      if (searchOptions.useBaseCriteria) {\n        criterias = self.options.baseCriteria.slice(0);\n      }\n      if (term) {\n        term += '*';\n        criterias.push({\n          i: self.options.searchParam,\n          o: 'plone.app.querystring.operation.string.contains',\n          v: term\n        });\n      }\n      if (searchOptions.searchPath) {\n        criterias.push({\n          i: 'path',\n          o: self.options.pathOperator,\n          v: searchOptions.searchPath + '::' + self.options.pathDepth\n        });\n      } else if (self.pattern.browsing) {\n        criterias.push({\n          i: 'path',\n          o: self.options.pathOperator,\n          v: self.getCurrentPath() + '::' + self.options.pathDepth\n        });\n      }\n      criterias = criterias.concat(searchOptions.additionalCriterias);\n      return criterias;\n    };\n\n    self.getQueryData = function(term, page) {\n      var data = {\n        query: JSON.stringify({\n          criteria: self.getCriterias(term),\n          sort_on: self.options.sort_on,\n          sort_order: self.options.sort_order\n        }),\n        attributes: JSON.stringify(self.options.attributes)\n      };\n      if (page) {\n        data.batch = JSON.stringify(self.getBatch(page));\n      }\n      return data;\n    };\n\n    self.getUrl = function() {\n      var url = self.options.vocabularyUrl;\n      if (url.indexOf('?') === -1) {\n        url += '?';\n      } else {\n        url += '&';\n      }\n      return url + $.param(self.getQueryData());\n    };\n\n    self.selectAjax = function() {\n      return {\n        url: self.options.vocabularyUrl,\n        dataType: 'JSON',\n        quietMillis: 100,\n        data: function(term, page) {\n          return self.getQueryData(term, page);\n        },\n        results: function(data, page) {\n          var more = (page * 10) < data.total; // whether or not there are more results available\n          // notice we return the value of more so Select2 knows if more results can be loaded\n          return {\n            results: data.results,\n            more: more\n          };\n        }\n      };\n    };\n\n    self.search = function(term, operation, value, callback, useBaseCriteria, type) {\n      if (useBaseCriteria === undefined) {\n        useBaseCriteria = true;\n      }\n      if (type === undefined) {\n        type = 'GET';\n      }\n      var criteria = [];\n      if (useBaseCriteria) {\n        criteria = self.options.baseCriteria.slice(0);\n      }\n      criteria.push({\n        i: term,\n        o: operation,\n        v: value\n      });\n      var data = {\n        query: JSON.stringify({\n          criteria: criteria\n        }),\n        attributes: JSON.stringify(self.options.attributes)\n      };\n      $.ajax({\n        url: self.options.vocabularyUrl,\n        dataType: 'JSON',\n        data: data,\n        type: type,\n        success: callback\n      });\n    };\n\n    return self;\n  };\n\n  var Loading = function(options) {\n    /*\n     * Options:\n     *   backdrop(pattern): if you want to have the progress indicator work\n     *                      seamlessly with backdrop pattern\n     *   zIndex(integer or function): to override default z-index used\n     */\n    var self = this;\n    self.className = 'plone-loader';\n    var defaults = {\n      backdrop: null,\n      zIndex: 10005 // can be a function\n    };\n    if (!options) {\n      options = {};\n    }\n    self.options = $.extend({}, defaults, options);\n\n    self.init = function() {\n      self.$el = $('.' + self.className);\n      if (self.$el.length === 0) {\n        self.$el = $('<div><div></div></div>');\n        self.$el.addClass(self.className).hide().appendTo('body');\n      }\n    };\n\n    self.show = function(closable) {\n      self.init();\n      self.$el.show();\n      var zIndex = self.options.zIndex;\n      if (typeof(zIndex) === 'function') {\n        zIndex = Math.max(zIndex(), 10005);\n      } else {\n        // go through all modals and backdrops and make sure we have a higher\n        // z-index to use\n        zIndex = 10005;\n        $('.plone-modal-wrapper,.plone-modal-backdrop').each(function() {\n          zIndex = Math.max(zIndex, $(this).css('zIndex') || 10005);\n        });\n        zIndex += 1;\n      }\n      self.$el.css('zIndex', zIndex);\n\n      if (closable === undefined) {\n        closable = true;\n      }\n      if (self.options.backdrop) {\n        self.options.backdrop.closeOnClick = closable;\n        self.options.backdrop.closeOnEsc = closable;\n        self.options.backdrop.init();\n        self.options.backdrop.show();\n      }\n    };\n\n    self.hide = function() {\n      self.init();\n      self.$el.hide();\n    };\n\n    return self;\n  };\n\n  var getAuthenticator = function() {\n    var $el = $('input[name=\"_authenticator\"]');\n    if ($el.length === 0) {\n      $el = $('a[href*=\"_authenticator\"]');\n      if ($el.length > 0) {\n        return $el.attr('href').split('_authenticator=')[1];\n      }\n      return '';\n    } else {\n      return $el.val();\n    }\n  };\n\n  var generateId = function(prefix) {\n    if (prefix === undefined) {\n      prefix = 'id';\n    }\n    return prefix + (Math.floor((1 + Math.random()) * 0x10000)\n      .toString(16).substring(1));\n  };\n\n  var setId = function($el, prefix) {\n    if (prefix === undefined) {\n      prefix = 'id';\n    }\n    var id = $el.attr('id');\n    if (id === undefined) {\n      id = generateId(prefix);\n    } else {\n      /* hopefully we don't screw anything up here... changing the id\n       * in some cases so we get a decent selector */\n      id = id.replace(/\\./g, '-');\n    }\n    $el.attr('id', id);\n    return id;\n  };\n\n  var getWindow = function() {\n    var win = window;\n    if (win.parent !== window) {\n      win = win.parent;\n    }\n    return win;\n  };\n\n  var parseBodyTag = function(txt) {\n    return $((/<body[^>]*>[^]*<\\/body>/im).exec(txt)[0]\n      .replace('<body', '<div').replace('</body>', '</div>')).eq(0).html();\n  };\n\n  var featureSupport = {\n    /* Well tested feature support for things we use in mockup.\n     * All gathered from: http://diveintohtml5.info/everything.html\n     * Alternative to using some form of modernizr.\n     */\n    dragAndDrop: function() {\n      return 'draggable' in document.createElement('span');\n    },\n    fileApi: function() {\n      return typeof FileReader != 'undefined'; // jshint ignore:line\n    },\n    history: function() {\n      return !!(window.history && window.history.pushState);\n    }\n  };\n\n  var bool = function(val) {\n    if (typeof val === 'string') {\n      val = $.trim(val).toLowerCase();\n    }\n    return ['false', false, '0', 0, '', undefined, null].indexOf(val) === -1;\n  };\n\n  var escapeHTML = function(val) {\n    return $('<div/>').text(val).html();\n  };\n\n  var removeHTML = function(val) {\n    return val.replace(/<[^>]+>/ig, '');\n  };\n\n  var storage = {\n    // Simple local storage wrapper, which doesn't break down if it's not available.\n    get: function (name) {\n        if (window.localStorage) {\n          var val = window.localStorage[name];\n          return typeof(val) === 'string' ? JSON.parse(val) : undefined;\n      }\n    },\n\n    set: function (name, val) {\n      if (window.localStorage) {\n        window.localStorage[name] = JSON.stringify(val);\n      }\n    }\n  };\n\n  return {\n    bool: bool,\n    escapeHTML: escapeHTML,\n    removeHTML: removeHTML,\n    featureSupport: featureSupport,\n    generateId: generateId,\n    getAuthenticator: getAuthenticator,\n    getWindow: getWindow,\n    Loading: Loading,\n    loading: new Loading(),  // provide default loader\n    parseBodyTag: parseBodyTag,\n    QueryHelper: QueryHelper,\n    setId: setId,\n    storage: storage\n  };\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n\n//# sourceURL=webpack:///./.plone/++resource++mockupjs/utils.js?");

/***/ })

}]);